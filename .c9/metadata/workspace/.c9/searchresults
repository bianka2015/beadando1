{"changed":true,"filter":false,"title":"Search Results","tooltip":"/.c9/searchresults","value":"Searching for \u0001gitignore\u0001 in\u0001/\u0001 (Found 137 matches in 58 files)\n\n/bower_components/bootswatch/bower.json:\n\t22:     \".gitignore\",\n\n/node_modules/bower/node_modules/fstream-ignore/package.json:\n\t29:   \"readme\": \"# fstream-ignore\\n\\nA fstream DirReader that filters out files that match globs in `.ignore`\\nfiles throughout the tree, like how git ignores files based on a\\n`.gitignore` file.\\n\\nHere's an example:\\n\\n```javascript\\nvar Ignore = require(\\\"fstream-ignore\\\")\\nIgnore({ path: __dirname\\n       , ignoreFiles: [\\\".ignore\\\", \\\".gitignore\\\"]\\n       })\\n  .on(\\\"child\\\", function (c) {\\n    console.error(c.path.substr(c.root.path.length + 1))\\n  })\\n  .pipe(tar.Pack())\\n  .pipe(fs.createWriteStream(\\\"foo.tar\\\"))\\n```\\n\\nThis will tar up the files in __dirname into `foo.tar`, ignoring\\nanything matched by the globs in any .iginore or .gitignore file.\\n\",\n\n/node_modules/bower/node_modules/fstream-ignore/README.md:\n\t5: `.gitignore` file.\n\t12:        , ignoreFiles: [\".ignore\", \".gitignore\"]\n\t22: anything matched by the globs in any .iginore or .gitignore file.\n\n/node_modules/bower/node_modules/fstream-ignore/example/basic.js:\n\t3:        , ignoreFiles: [\".ignore\", \".gitignore\"]\n\n/node_modules/bower/node_modules/fstream-ignore/node_modules/minimatch/package.json:\n\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",\n\n/node_modules/bower/node_modules/fstream-ignore/node_modules/minimatch/README.md:\n\t36: * `man 5 gitignore`\n\n/node_modules/bower/node_modules/fstream-ignore/test/read-file-order.js:\n\t6: c.ignores({ \".gitignore\": [\"a/b/c/abc\"] })\n\t20: // Overwrite fs.readFile so that when .gitignore and .ignore are read in\n\t41:       if (filename.indexOf('.gitignore') !== -1) {\n\t62:              , ignoreFiles: [\".gitignore\", \".ignore\"] })\n\n/node_modules/bower/node_modules/github/package.json:\n\t45:   \"readme\": \"# JavaScript GitHub API for Node.JS\\n\\nA Node.JS module, which provides an object oriented wrapper for the GitHub v3 API.\\n\\n## Installation\\n\\n  Install with the Node.JS package manager [npm](http://npmjs.org/) ![NPM version](https://badge.fury.io/js/github.svg):\\n\\n      $ npm install github\\n\\nor\\n\\n  Install via git clone:\\n\\n      $ git clone git://github.com/mikedeboer/node-github.git\\n      $ cd node-github\\n      $ npm install\\n\\n## Documentation\\n\\nYou can find the docs for the API of this client at [http://mikedeboer.github.com/node-github/](http://mikedeboer.github.com/node-github/)\\n\\nAdditionally, the [official Github documentation](https://developer.github.com/v3/)\\nis a very useful resource.\\n\\n## Example\\n\\nPrint all followers of the user \\\"mikedeboer\\\" to the console.\\n```javascript\\nvar GitHubApi = require(\\\"github\\\");\\n\\nvar github = new GitHubApi({\\n    // required\\n    version: \\\"3.0.0\\\",\\n    // optional\\n    debug: true,\\n    protocol: \\\"https\\\",\\n    host: \\\"github.my-GHE-enabled-company.com\\\", // should be api.github.com for GitHub\\n    pathPrefix: \\\"/api/v3\\\", // for some GHEs; none for GitHub\\n    timeout: 5000,\\n    headers: {\\n        \\\"user-agent\\\": \\\"My-Cool-GitHub-App\\\" // GitHub is happy with a unique user agent\\n    }\\n});\\ngithub.user.getFollowingFromUser({\\n    // optional:\\n    // headers: {\\n    //     \\\"cookie\\\": \\\"blahblah\\\"\\n    // },\\n    user: \\\"mikedeboer\\\"\\n}, function(err, res) {\\n    console.log(JSON.stringify(res));\\n});\\n```\\n\\nFirst the _GitHubApi_ class is imported from the _node-github_ module. This class provides\\naccess to all of GitHub's APIs (e.g. user, issues or repo APIs). The _getFollowingFromUser_\\nmethod lists all followers of a given GitHub user. Is is part of the user API. It\\ntakes the user name as first argument and a callback as last argument. Once the\\nfollower list is returned from the server, the callback is called.\\n\\nLike in Node.JS, callbacks are always the last argument. If the functions fails an\\nerror object is passed as first argument to the callback.\\n\\n## Authentication\\n\\nMost GitHub API calls don't require authentication. As a rule of thumb: If you\\ncan see the information by visiting the site without being logged in, you don't\\nhave to be authenticated to retrieve the same information through the API. Of\\ncourse calls, which change data or read sensitive information have to be authenticated.\\n\\nYou need the GitHub user name and the API key for authentication. The API key can\\nbe found in the user's _Account Settings_ page.\\n\\nThis example shows how to authenticate and then change _location_ field of the\\naccount settings to _Argentina_:\\n```javascript\\ngithub.authenticate({\\n    type: \\\"basic\\\",\\n    username: username,\\n    password: password\\n});\\ngithub.user.update({\\n    location: \\\"Argentina\\\"\\n}, function(err) {\\n    console.log(\\\"done!\\\");\\n});\\n```\\nNote that the _authenticate_ method is synchronous because it only stores the\\ncredentials for the next request.\\n\\nOther examples for the various authentication methods:\\n```javascript\\n// OAuth2\\ngithub.authenticate({\\n    type: \\\"oauth\\\",\\n    token: token\\n});\\n\\n// OAuth2 Key/Secret\\ngithub.authenticate({\\n    type: \\\"oauth\\\",\\n    key: \\\"clientID\\\",\\n    secret: \\\"clientSecret\\\"\\n})\\n\\n// Deprecated Gihub API token (seems not to be working with the v3 API)\\ngithub.authenticate({\\n    type: \\\"token\\\",\\n    token: token\\n});\\n```\\n\\n### Creating tokens for your application\\n[Create a new authorization](http://developer.github.com/v3/oauth/#create-a-new-authorization) for your application giving it access to the wanted scopes you need instead of relying on username / password and is the way to go if you have [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) on.\\n\\nFor example:\\n\\n1. Use github.authenticate() to auth with GitHub using your username / password\\n2. Create an application token programmatically with the scopes you need and, if you use two-factor authentication send the `X-GitHub-OTP` header with the one-time-password you get on your token device.\\n\\n```javascript\\ngithub.authorization.create({\\n    scopes: [\\\"user\\\", \\\"public_repo\\\", \\\"repo\\\", \\\"repo:status\\\", \\\"gist\\\"],\\n    note: \\\"what this auth is for\\\",\\n    note_url: \\\"http://url-to-this-auth-app\\\",\\n    headers: {\\n        \\\"X-GitHub-OTP\\\": \\\"two-factor-code\\\"\\n    }\\n}, function(err, res) {\\n    if (res.token) {\\n        //save and use res.token as in the Oauth process above from now on\\n    }\\n});\\n```\\n\\n## Implemented GitHub APIs\\n\\n* Gists: 100%\\n* Git Data: 100%\\n* Issues: 100%\\n* Orgs: 100%\\n* Pull Requests: 100%\\n* Repos: 100%\\n* Users: 100%\\n* Events: 100%\\n* Search: 100%\\n* Markdown: 100%\\n* Rate Limit: 100%\\n* Releases: 100%\\n* Gitignore: 100%\\n* Meta: 100%\\n* Emojis: 100%\\n\\n## Running the Tests\\n\\nThe unit tests are based on the [mocha](http://visionmedia.github.com/mocha/)\\nmodule, which may be installed via npm. To run the tests make sure that the\\nnpm dependencies are installed by running `npm install` from the project directory.\\n\\nBefore running unit tests:\\n```shell\\nnpm install mocha -g\\n```\\nAt the moment, test classes can only be run separately. This will e.g. run the Issues Api test:\\n```shell\\nmocha api/v3.0.0/issuesTest.js\\n```\\nNote that a connection to the internet is required to run the tests.\\n\\n## LICENSE\\n\\nMIT license. See the LICENSE file for details.\\n\",\n\n/node_modules/bower/node_modules/github/README.md:\n\t151: * Gitignore: 100%\n\n/node_modules/bower/node_modules/github/api/v3.0.0/gitignore.js:\n\t2:  *  mixin gitignore\n\t17: var gitignore = module.exports = {\n\t18:     gitignore: {}\n\t23:      *  gitignore#templates(msg, callback) -> null\n\t68:      *  gitignore#template(msg, callback) -> null\n\t75:      *  - name (String): Required. The name of the .gitignore template to get\n\t112: }).call(gitignore.gitignore);\n\n/node_modules/bower/node_modules/github/api/v3.0.0/gitignoreTest.js:\n\t15: describe(\"[gitignore]\", function() {\n\t24:     it(\"should successfully execute GET /gitignore/templates (templates)\",  function(next) {\n\t25:         client.gitignore.templates(\n\t38:     it(\"should successfully execute GET /gitignore/templates/:name (template)\",  function(next) {\n\t39:         client.gitignore.template(\n\n/node_modules/bower/node_modules/github/api/v3.0.0/index.js:\n\t36: [\"gists\", \"gitdata\", \"issues\", \"authorization\", \"orgs\", \"statuses\", \"pullRequests\", \"repos\", \"user\", \"events\", \"releases\", \"search\", \"markdown\", \"gitignore\", \"misc\"].forEach(function(api) {\n\n/node_modules/bower/node_modules/github/api/v3.0.0/repos.js:\n\t185:      *  - gitignore_template (String): Optional. Desired language or platform .gitignore template to apply. Ignored if auto_init parameter is not provided.\n\t239:      *  - gitignore_template (String): Optional. Desired language or platform .gitignore template to apply. Ignored if auto_init parameter is not provided.\n\n/node_modules/bower/node_modules/github/api/v3.0.0/reposTest.js:\n\t91:                 gitignore_template: \"String\"\n\t113:                 gitignore_template: \"String\",\n\n/node_modules/bower/node_modules/github/api/v3.0.0/routes.json:\n\t313:             \"gitignore_template\": {\n\t318:                 \"description\": \"Desired language or platform .gitignore template to apply. Ignored if auto_init parameter is not provided.\"\n\t1963:                 \"$gitignore_template\": null\n\t1980:                 \"$gitignore_template\": null,\n\t3876:     \"gitignore\": {\n\t3878:             \"url\": \"/gitignore/templates\",\n\t3883:             \"url\": \"/gitignore/templates/:name\",\n\t3891:                     \"description\": \"The name of the .gitignore template to get\"\n\n/node_modules/bower/node_modules/glob/package.json:\n\t45:   \"readme\": \"[![Build Status](https://travis-ci.org/isaacs/node-glob.svg?branch=master)](https://travis-ci.org/isaacs/node-glob/) [![Dependency Status](https://david-dm.org/isaacs/node-glob.svg)](https://david-dm.org/isaacs/node-glob) [![devDependency Status](https://david-dm.org/isaacs/node-glob/dev-status.svg)](https://david-dm.org/isaacs/node-glob#info=devDependencies) [![optionalDependency Status](https://david-dm.org/isaacs/node-glob/optional-status.svg)](https://david-dm.org/isaacs/node-glob#info=optionalDependencies)\\n\\n# Glob\\n\\nMatch files using the patterns the shell uses, like stars and stuff.\\n\\nThis is a glob implementation in JavaScript.  It uses the `minimatch`\\nlibrary to do its matching.\\n\\n![](oh-my-glob.gif)\\n\\n## Usage\\n\\n```javascript\\nvar glob = require(\\\"glob\\\")\\n\\n// options is optional\\nglob(\\\"**/*.js\\\", options, function (er, files) {\\n  // files is an array of filenames.\\n  // If the `nonull` option is set, and nothing\\n  // was found, then files is [\\\"**/*.js\\\"]\\n  // er is an error object or null.\\n})\\n```\\n\\n## Glob Primer\\n\\n\\\"Globs\\\" are the patterns you type when you do stuff like `ls *.js` on\\nthe command line, or put `build/*` in a `.gitignore` file.\\n\\nBefore parsing the path part patterns, braced sections are expanded\\ninto a set.  Braced sections start with `{` and end with `}`, with any\\nnumber of comma-delimited sections within.  Braced sections may contain\\nslash characters, so `a{/b/c,bcd}` would expand into `a/b/c` and `abcd`.\\n\\nThe following characters have special magic meaning when used in a\\npath portion:\\n\\n* `*` Matches 0 or more characters in a single path portion\\n* `?` Matches 1 character\\n* `[...]` Matches a range of characters, similar to a RegExp range.\\n  If the first character of the range is `!` or `^` then it matches\\n  any character not in the range.\\n* `!(pattern|pattern|pattern)` Matches anything that does not match\\n  any of the patterns provided.\\n* `?(pattern|pattern|pattern)` Matches zero or one occurrence of the\\n  patterns provided.\\n* `+(pattern|pattern|pattern)` Matches one or more occurrences of the\\n  patterns provided.\\n* `*(a|b|c)` Matches zero or more occurrences of the patterns provided\\n* `@(pattern|pat*|pat?erN)` Matches exactly one of the patterns\\n  provided\\n* `**` If a \\\"globstar\\\" is alone in a path portion, then it matches\\n  zero or more directories and subdirectories searching for matches.\\n  It does not crawl symlinked directories.\\n\\n### Dots\\n\\nIf a file or directory path portion has a `.` as the first character,\\nthen it will not match any glob pattern unless that pattern's\\ncorresponding path part also has a `.` as its first character.\\n\\nFor example, the pattern `a/.*/c` would match the file at `a/.b/c`.\\nHowever the pattern `a/*/c` would not, because `*` does not start with\\na dot character.\\n\\nYou can make glob treat dots as normal characters by setting\\n`dot:true` in the options.\\n\\n### Basename Matching\\n\\nIf you set `matchBase:true` in the options, and the pattern has no\\nslashes in it, then it will seek for any file anywhere in the tree\\nwith a matching basename.  For example, `*.js` would match\\n`test/simple/basic.js`.\\n\\n### Negation\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird, and for the time being, this should be\\navoided.  The behavior will change or be deprecated in version 5.\\n\\n### Empty Sets\\n\\nIf no matching files are found, then an empty array is returned.  This\\ndiffers from the shell, where the pattern itself is returned.  For\\nexample:\\n\\n    $ echo a*s*d*f\\n    a*s*d*f\\n\\nTo get the bash-style behavior, set the `nonull:true` in the options.\\n\\n### See Also:\\n\\n* `man sh`\\n* `man bash` (Search for \\\"Pattern Matching\\\")\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n* [minimatch documentation](https://github.com/isaacs/minimatch)\\n\\n## glob.hasMagic(pattern, [options])\\n\\nReturns `true` if there are any special characters in the pattern, and\\n`false` otherwise.\\n\\nNote that the options affect the results.  If `noext:true` is set in\\nthe options object, then `+(a|b)` will not be considered a magic\\npattern.  If the pattern has a brace expansion, like `a/{b/c,x/y}`\\nthen that is considered magical, unless `nobrace:true` is set in the\\noptions.\\n\\n## glob(pattern, [options], cb)\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* `cb` {Function}\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nPerform an asynchronous glob search.\\n\\n## glob.sync(pattern, [options])\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* return: {Array<String>} filenames found matching the pattern\\n\\nPerform a synchronous glob search.\\n\\n## Class: glob.Glob\\n\\nCreate a Glob object by instantiating the `glob.Glob` class.\\n\\n```javascript\\nvar Glob = require(\\\"glob\\\").Glob\\nvar mg = new Glob(pattern, options, cb)\\n```\\n\\nIt's an EventEmitter, and starts walking the filesystem to find matches\\nimmediately.\\n\\n### new glob.Glob(pattern, [options], [cb])\\n\\n* `pattern` {String} pattern to search for\\n* `options` {Object}\\n* `cb` {Function} Called when an error occurs, or matches are found\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nNote that if the `sync` flag is set in the options, then matches will\\nbe immediately available on the `g.found` member.\\n\\n### Properties\\n\\n* `minimatch` The minimatch object that the glob uses.\\n* `options` The options object passed in.\\n* `aborted` Boolean which is set to true when calling `abort()`.  There\\n  is no way at this time to continue a glob search after aborting, but\\n  you can re-use the statCache to avoid having to duplicate syscalls.\\n* `statCache` Collection of all the stat results the glob search\\n  performed.\\n* `cache` Convenience object.  Each field has the following possible\\n  values:\\n  * `false` - Path does not exist\\n  * `true` - Path exists\\n  * `'DIR'` - Path exists, and is not a directory\\n  * `'FILE'` - Path exists, and is a directory\\n  * `[file, entries, ...]` - Path exists, is a directory, and the\\n    array value is the results of `fs.readdir`\\n* `statCache` Cache of `fs.stat` results, to prevent statting the same\\n  path multiple times.\\n* `symlinks` A record of which paths are symbolic links, which is\\n  relevant in resolving `**` patterns.\\n* `realpathCache` An optional object which is passed to `fs.realpath`\\n  to minimize unnecessary syscalls.  It is stored on the instantiated\\n  Glob object, and may be re-used.\\n\\n### Events\\n\\n* `end` When the matching is finished, this is emitted with all the\\n  matches found.  If the `nonull` option is set, and no match was found,\\n  then the `matches` list contains the original pattern.  The matches\\n  are sorted, unless the `nosort` flag is set.\\n* `match` Every time a match is found, this is emitted with the matched.\\n* `error` Emitted when an unexpected error is encountered, or whenever\\n  any fs error occurs if `options.strict` is set.\\n* `abort` When `abort()` is called, this event is raised.\\n\\n### Methods\\n\\n* `pause` Temporarily stop the search\\n* `resume` Resume the search\\n* `abort` Stop the search forever\\n\\n### Options\\n\\nAll the options that can be passed to Minimatch can also be passed to\\nGlob to change pattern matching behavior.  Also, some have been added,\\nor have glob-specific ramifications.\\n\\nAll options are false by default, unless otherwise noted.\\n\\nAll options are added to the Glob object, as well.\\n\\nIf you are running many `glob` operations, you can pass a Glob object\\nas the `options` argument to a subsequent operation to shortcut some\\n`stat` and `readdir` calls.  At the very least, you may pass in shared\\n`symlinks`, `statCache`, `realpathCache`, and `cache` options, so that\\nparallel glob operations will be sped up by sharing information about\\nthe filesystem.\\n\\n* `cwd` The current working directory in which to search.  Defaults\\n  to `process.cwd()`.\\n* `root` The place where patterns starting with `/` will be mounted\\n  onto.  Defaults to `path.resolve(options.cwd, \\\"/\\\")` (`/` on Unix\\n  systems, and `C:\\\\` or some such on Windows.)\\n* `dot` Include `.dot` files in normal matches and `globstar` matches.\\n  Note that an explicit dot in a portion of the pattern will always\\n  match dot files.\\n* `nomount` By default, a pattern starting with a forward-slash will be\\n  \\\"mounted\\\" onto the root setting, so that a valid filesystem path is\\n  returned.  Set this flag to disable that behavior.\\n* `mark` Add a `/` character to directory matches.  Note that this\\n  requires additional stat calls.\\n* `nosort` Don't sort the results.\\n* `stat` Set to true to stat *all* results.  This reduces performance\\n  somewhat, and is completely unnecessary, unless `readdir` is presumed\\n  to be an untrustworthy indicator of file existence.\\n* `silent` When an unusual error is encountered when attempting to\\n  read a directory, a warning will be printed to stderr.  Set the\\n  `silent` option to true to suppress these warnings.\\n* `strict` When an unusual error is encountered when attempting to\\n  read a directory, the process will just continue on in search of\\n  other matches.  Set the `strict` option to raise an error in these\\n  cases.\\n* `cache` See `cache` property above.  Pass in a previously generated\\n  cache object to save some fs calls.\\n* `statCache` A cache of results of filesystem information, to prevent\\n  unnecessary stat calls.  While it should not normally be necessary\\n  to set this, you may pass the statCache from one glob() call to the\\n  options object of another, if you know that the filesystem will not\\n  change between calls.  (See \\\"Race Conditions\\\" below.)\\n* `symlinks` A cache of known symbolic links.  You may pass in a\\n  previously generated `symlinks` object to save `lstat` calls when\\n  resolving `**` matches.\\n* `sync` DEPRECATED: use `glob.sync(pattern, opts)` instead.\\n* `nounique` In some cases, brace-expanded patterns can result in the\\n  same file showing up multiple times in the result set.  By default,\\n  this implementation prevents duplicates in the result set.  Set this\\n  flag to disable that behavior.\\n* `nonull` Set to never return an empty set, instead returning a set\\n  containing the pattern itself.  This is the default in glob(3).\\n* `debug` Set to enable debug logging in minimatch and glob.\\n* `nobrace` Do not expand `{a,b}` and `{1..3}` brace sets.\\n* `noglobstar` Do not match `**` against multiple filenames.  (Ie,\\n  treat it as a normal `*` instead.)\\n* `noext` Do not match `+(a|b)` \\\"extglob\\\" patterns.\\n* `nocase` Perform a case-insensitive match.  Note: on\\n  case-insensitive filesystems, non-magic patterns will match by\\n  default, since `stat` and `readdir` will not raise errors.\\n* `matchBase` Perform a basename-only match if the pattern does not\\n  contain any slash characters.  That is, `*.js` would be treated as\\n  equivalent to `**/*.js`, matching all js files in all directories.\\n* `nonegate` Suppress `negate` behavior.  (See below.)\\n* `nocomment` Suppress `comment` behavior.  (See below.)\\n* `nonull` Return the pattern when no matches are found.\\n* `nodir` Do not match directories, only files.  (Note: to match\\n  *only* directories, simply put a `/` at the end of the pattern.)\\n* `ignore` Add a pattern or an array of patterns to exclude matches.\\n* `follow` Follow symlinked directories when expanding `**` patterns.\\n  Note that this can result in a lot of duplicate references in the\\n  presence of cyclic links.\\n* `realpath` Set to true to call `fs.realpath` on all of the results.\\n  In the case of a symlink that cannot be resolved, the full absolute\\n  path to the matched entry is returned (though it will usually be a\\n  broken symlink)\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between node-glob and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.3, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nNote that symlinked directories are not crawled as part of a `**`,\\nthough their contents may match against subsequent portions of the\\npattern.  This prevents infinite loops and duplicates and the like.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen glob returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`glob.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\\n## Windows\\n\\n**Please only use forward-slashes in glob expressions.**\\n\\nThough windows uses either `/` or `\\\\` as its path separator, only `/`\\ncharacters are used by this glob implementation.  You must use\\nforward-slashes **only** in glob expressions.  Back-slashes will always\\nbe interpreted as escape characters, not path separators.\\n\\nResults from absolute patterns such as `/foo/*` are mounted onto the\\nroot setting using `path.join`.  On windows, this will by default result\\nin `/foo/*` matching `C:\\\\foo\\\\bar.txt`.\\n\\n## Race Conditions\\n\\nGlob searching, by its very nature, is susceptible to race conditions,\\nsince it relies on directory walking and such.\\n\\nAs a result, it is possible that a file that exists when glob looks for\\nit may have been deleted or modified by the time it returns the result.\\n\\nAs part of its internal implementation, this program caches all stat\\nand readdir calls that it makes, in order to cut down on system\\noverhead.  However, this also makes it even more susceptible to races,\\nespecially if the cache or statCache objects are reused between glob\\ncalls.\\n\\nUsers are thus advised not to use a glob result as a guarantee of\\nfilesystem state in the face of rapid changes.  For the vast majority\\nof operations, this is never a problem.\\n\\n## Contributing\\n\\nAny change to behavior (including bugfixes) must come with a test.\\n\\nPatches that fail tests or reduce performance will be rejected.\\n\\n```\\n# to run tests\\nnpm test\\n\\n# to re-generate test fixtures\\nnpm run test-regen\\n\\n# to benchmark against bash/zsh\\nnpm run bench\\n\\n# to profile javascript\\nnpm run prof\\n```\\n\",\n\n/node_modules/bower/node_modules/glob/README.md:\n\t29: the command line, or put `build/*` in a `.gitignore` file.\n\t100: * `man 5 gitignore`\n\n/node_modules/bower/node_modules/glob/node_modules/minimatch/package.json:\n\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",\n\n/node_modules/bower/node_modules/glob/node_modules/minimatch/README.md:\n\t36: * `man 5 gitignore`\n\n/node_modules/bower/node_modules/rimraf/node_modules/glob/package.json:\n\t46:   \"readme\": \"[![Build Status](https://travis-ci.org/isaacs/node-glob.svg?branch=master)](https://travis-ci.org/isaacs/node-glob/) [![Dependency Status](https://david-dm.org/isaacs/node-glob.svg)](https://david-dm.org/isaacs/node-glob) [![devDependency Status](https://david-dm.org/isaacs/node-glob/dev-status.svg)](https://david-dm.org/isaacs/node-glob#info=devDependencies) [![optionalDependency Status](https://david-dm.org/isaacs/node-glob/optional-status.svg)](https://david-dm.org/isaacs/node-glob#info=optionalDependencies)\\n\\n# Glob\\n\\nMatch files using the patterns the shell uses, like stars and stuff.\\n\\nThis is a glob implementation in JavaScript.  It uses the `minimatch`\\nlibrary to do its matching.\\n\\n![](oh-my-glob.gif)\\n\\n## Usage\\n\\n```javascript\\nvar glob = require(\\\"glob\\\")\\n\\n// options is optional\\nglob(\\\"**/*.js\\\", options, function (er, files) {\\n  // files is an array of filenames.\\n  // If the `nonull` option is set, and nothing\\n  // was found, then files is [\\\"**/*.js\\\"]\\n  // er is an error object or null.\\n})\\n```\\n\\n## Glob Primer\\n\\n\\\"Globs\\\" are the patterns you type when you do stuff like `ls *.js` on\\nthe command line, or put `build/*` in a `.gitignore` file.\\n\\nBefore parsing the path part patterns, braced sections are expanded\\ninto a set.  Braced sections start with `{` and end with `}`, with any\\nnumber of comma-delimited sections within.  Braced sections may contain\\nslash characters, so `a{/b/c,bcd}` would expand into `a/b/c` and `abcd`.\\n\\nThe following characters have special magic meaning when used in a\\npath portion:\\n\\n* `*` Matches 0 or more characters in a single path portion\\n* `?` Matches 1 character\\n* `[...]` Matches a range of characters, similar to a RegExp range.\\n  If the first character of the range is `!` or `^` then it matches\\n  any character not in the range.\\n* `!(pattern|pattern|pattern)` Matches anything that does not match\\n  any of the patterns provided.\\n* `?(pattern|pattern|pattern)` Matches zero or one occurrence of the\\n  patterns provided.\\n* `+(pattern|pattern|pattern)` Matches one or more occurrences of the\\n  patterns provided.\\n* `*(a|b|c)` Matches zero or more occurrences of the patterns provided\\n* `@(pattern|pat*|pat?erN)` Matches exactly one of the patterns\\n  provided\\n* `**` If a \\\"globstar\\\" is alone in a path portion, then it matches\\n  zero or more directories and subdirectories searching for matches.\\n  It does not crawl symlinked directories.\\n\\n### Dots\\n\\nIf a file or directory path portion has a `.` as the first character,\\nthen it will not match any glob pattern unless that pattern's\\ncorresponding path part also has a `.` as its first character.\\n\\nFor example, the pattern `a/.*/c` would match the file at `a/.b/c`.\\nHowever the pattern `a/*/c` would not, because `*` does not start with\\na dot character.\\n\\nYou can make glob treat dots as normal characters by setting\\n`dot:true` in the options.\\n\\n### Basename Matching\\n\\nIf you set `matchBase:true` in the options, and the pattern has no\\nslashes in it, then it will seek for any file anywhere in the tree\\nwith a matching basename.  For example, `*.js` would match\\n`test/simple/basic.js`.\\n\\n### Negation\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird, and for the time being, this should be\\navoided.  The behavior is deprecated in version 5, and will be removed\\nentirely in version 6.\\n\\n### Empty Sets\\n\\nIf no matching files are found, then an empty array is returned.  This\\ndiffers from the shell, where the pattern itself is returned.  For\\nexample:\\n\\n    $ echo a*s*d*f\\n    a*s*d*f\\n\\nTo get the bash-style behavior, set the `nonull:true` in the options.\\n\\n### See Also:\\n\\n* `man sh`\\n* `man bash` (Search for \\\"Pattern Matching\\\")\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n* [minimatch documentation](https://github.com/isaacs/minimatch)\\n\\n## glob.hasMagic(pattern, [options])\\n\\nReturns `true` if there are any special characters in the pattern, and\\n`false` otherwise.\\n\\nNote that the options affect the results.  If `noext:true` is set in\\nthe options object, then `+(a|b)` will not be considered a magic\\npattern.  If the pattern has a brace expansion, like `a/{b/c,x/y}`\\nthen that is considered magical, unless `nobrace:true` is set in the\\noptions.\\n\\n## glob(pattern, [options], cb)\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* `cb` {Function}\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nPerform an asynchronous glob search.\\n\\n## glob.sync(pattern, [options])\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* return: {Array<String>} filenames found matching the pattern\\n\\nPerform a synchronous glob search.\\n\\n## Class: glob.Glob\\n\\nCreate a Glob object by instantiating the `glob.Glob` class.\\n\\n```javascript\\nvar Glob = require(\\\"glob\\\").Glob\\nvar mg = new Glob(pattern, options, cb)\\n```\\n\\nIt's an EventEmitter, and starts walking the filesystem to find matches\\nimmediately.\\n\\n### new glob.Glob(pattern, [options], [cb])\\n\\n* `pattern` {String} pattern to search for\\n* `options` {Object}\\n* `cb` {Function} Called when an error occurs, or matches are found\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nNote that if the `sync` flag is set in the options, then matches will\\nbe immediately available on the `g.found` member.\\n\\n### Properties\\n\\n* `minimatch` The minimatch object that the glob uses.\\n* `options` The options object passed in.\\n* `aborted` Boolean which is set to true when calling `abort()`.  There\\n  is no way at this time to continue a glob search after aborting, but\\n  you can re-use the statCache to avoid having to duplicate syscalls.\\n* `cache` Convenience object.  Each field has the following possible\\n  values:\\n  * `false` - Path does not exist\\n  * `true` - Path exists\\n  * `'DIR'` - Path exists, and is not a directory\\n  * `'FILE'` - Path exists, and is a directory\\n  * `[file, entries, ...]` - Path exists, is a directory, and the\\n    array value is the results of `fs.readdir`\\n* `statCache` Cache of `fs.stat` results, to prevent statting the same\\n  path multiple times.\\n* `symlinks` A record of which paths are symbolic links, which is\\n  relevant in resolving `**` patterns.\\n* `realpathCache` An optional object which is passed to `fs.realpath`\\n  to minimize unnecessary syscalls.  It is stored on the instantiated\\n  Glob object, and may be re-used.\\n\\n### Events\\n\\n* `end` When the matching is finished, this is emitted with all the\\n  matches found.  If the `nonull` option is set, and no match was found,\\n  then the `matches` list contains the original pattern.  The matches\\n  are sorted, unless the `nosort` flag is set.\\n* `match` Every time a match is found, this is emitted with the matched.\\n* `error` Emitted when an unexpected error is encountered, or whenever\\n  any fs error occurs if `options.strict` is set.\\n* `abort` When `abort()` is called, this event is raised.\\n\\n### Methods\\n\\n* `pause` Temporarily stop the search\\n* `resume` Resume the search\\n* `abort` Stop the search forever\\n\\n### Options\\n\\nAll the options that can be passed to Minimatch can also be passed to\\nGlob to change pattern matching behavior.  Also, some have been added,\\nor have glob-specific ramifications.\\n\\nAll options are false by default, unless otherwise noted.\\n\\nAll options are added to the Glob object, as well.\\n\\nIf you are running many `glob` operations, you can pass a Glob object\\nas the `options` argument to a subsequent operation to shortcut some\\n`stat` and `readdir` calls.  At the very least, you may pass in shared\\n`symlinks`, `statCache`, `realpathCache`, and `cache` options, so that\\nparallel glob operations will be sped up by sharing information about\\nthe filesystem.\\n\\n* `cwd` The current working directory in which to search.  Defaults\\n  to `process.cwd()`.\\n* `root` The place where patterns starting with `/` will be mounted\\n  onto.  Defaults to `path.resolve(options.cwd, \\\"/\\\")` (`/` on Unix\\n  systems, and `C:\\\\` or some such on Windows.)\\n* `dot` Include `.dot` files in normal matches and `globstar` matches.\\n  Note that an explicit dot in a portion of the pattern will always\\n  match dot files.\\n* `nomount` By default, a pattern starting with a forward-slash will be\\n  \\\"mounted\\\" onto the root setting, so that a valid filesystem path is\\n  returned.  Set this flag to disable that behavior.\\n* `mark` Add a `/` character to directory matches.  Note that this\\n  requires additional stat calls.\\n* `nosort` Don't sort the results.\\n* `stat` Set to true to stat *all* results.  This reduces performance\\n  somewhat, and is completely unnecessary, unless `readdir` is presumed\\n  to be an untrustworthy indicator of file existence.\\n* `silent` When an unusual error is encountered when attempting to\\n  read a directory, a warning will be printed to stderr.  Set the\\n  `silent` option to true to suppress these warnings.\\n* `strict` When an unusual error is encountered when attempting to\\n  read a directory, the process will just continue on in search of\\n  other matches.  Set the `strict` option to raise an error in these\\n  cases.\\n* `cache` See `cache` property above.  Pass in a previously generated\\n  cache object to save some fs calls.\\n* `statCache` A cache of results of filesystem information, to prevent\\n  unnecessary stat calls.  While it should not normally be necessary\\n  to set this, you may pass the statCache from one glob() call to the\\n  options object of another, if you know that the filesystem will not\\n  change between calls.  (See \\\"Race Conditions\\\" below.)\\n* `symlinks` A cache of known symbolic links.  You may pass in a\\n  previously generated `symlinks` object to save `lstat` calls when\\n  resolving `**` matches.\\n* `sync` DEPRECATED: use `glob.sync(pattern, opts)` instead.\\n* `nounique` In some cases, brace-expanded patterns can result in the\\n  same file showing up multiple times in the result set.  By default,\\n  this implementation prevents duplicates in the result set.  Set this\\n  flag to disable that behavior.\\n* `nonull` Set to never return an empty set, instead returning a set\\n  containing the pattern itself.  This is the default in glob(3).\\n* `debug` Set to enable debug logging in minimatch and glob.\\n* `nobrace` Do not expand `{a,b}` and `{1..3}` brace sets.\\n* `noglobstar` Do not match `**` against multiple filenames.  (Ie,\\n  treat it as a normal `*` instead.)\\n* `noext` Do not match `+(a|b)` \\\"extglob\\\" patterns.\\n* `nocase` Perform a case-insensitive match.  Note: on\\n  case-insensitive filesystems, non-magic patterns will match by\\n  default, since `stat` and `readdir` will not raise errors.\\n* `matchBase` Perform a basename-only match if the pattern does not\\n  contain any slash characters.  That is, `*.js` would be treated as\\n  equivalent to `**/*.js`, matching all js files in all directories.\\n* `nodir` Do not match directories, only files.  (Note: to match\\n  *only* directories, simply put a `/` at the end of the pattern.)\\n* `ignore` Add a pattern or an array of patterns to exclude matches.\\n* `follow` Follow symlinked directories when expanding `**` patterns.\\n  Note that this can result in a lot of duplicate references in the\\n  presence of cyclic links.\\n* `realpath` Set to true to call `fs.realpath` on all of the results.\\n  In the case of a symlink that cannot be resolved, the full absolute\\n  path to the matched entry is returned (though it will usually be a\\n  broken symlink)\\n* `nonegate` Suppress deprecated `negate` behavior.  (See below.)\\n  Default=true\\n* `nocomment` Suppress deprecated `comment` behavior.  (See below.)\\n  Default=true\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between node-glob and other\\nimplementations, and are intentional.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.3, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nNote that symlinked directories are not crawled as part of a `**`,\\nthough their contents may match against subsequent portions of the\\npattern.  This prevents infinite loops and duplicates and the like.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen glob returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`glob.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\\n### Comments and Negation\\n\\n**Note**: In version 5 of this module, negation and comments are\\n**disabled** by default.  You can explicitly set `nonegate:false` or\\n`nocomment:false` to re-enable them.  They are going away entirely in\\nversion 6.\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird.  It is better to use the `ignore` option\\nto set a pattern or set of patterns to exclude from matches.  If you\\nwant the \\\"everything except *x*\\\" type of behavior, you can use `**` as\\nthe main pattern, and set an `ignore` for the things to exclude.\\n\\nThe comments feature is added in minimatch, primarily to more easily\\nsupport use cases like ignore files, where a `#` at the start of a\\nline makes the pattern \\\"empty\\\".  However, in the context of a\\nstraightforward filesystem globber, \\\"comments\\\" don't make much sense.\\n\\n## Windows\\n\\n**Please only use forward-slashes in glob expressions.**\\n\\nThough windows uses either `/` or `\\\\` as its path separator, only `/`\\ncharacters are used by this glob implementation.  You must use\\nforward-slashes **only** in glob expressions.  Back-slashes will always\\nbe interpreted as escape characters, not path separators.\\n\\nResults from absolute patterns such as `/foo/*` are mounted onto the\\nroot setting using `path.join`.  On windows, this will by default result\\nin `/foo/*` matching `C:\\\\foo\\\\bar.txt`.\\n\\n## Race Conditions\\n\\nGlob searching, by its very nature, is susceptible to race conditions,\\nsince it relies on directory walking and such.\\n\\nAs a result, it is possible that a file that exists when glob looks for\\nit may have been deleted or modified by the time it returns the result.\\n\\nAs part of its internal implementation, this program caches all stat\\nand readdir calls that it makes, in order to cut down on system\\noverhead.  However, this also makes it even more susceptible to races,\\nespecially if the cache or statCache objects are reused between glob\\ncalls.\\n\\nUsers are thus advised not to use a glob result as a guarantee of\\nfilesystem state in the face of rapid changes.  For the vast majority\\nof operations, this is never a problem.\\n\\n## Contributing\\n\\nAny change to behavior (including bugfixes) must come with a test.\\n\\nPatches that fail tests or reduce performance will be rejected.\\n\\n```\\n# to run tests\\nnpm test\\n\\n# to re-generate test fixtures\\nnpm run test-regen\\n\\n# to benchmark against bash/zsh\\nnpm run bench\\n\\n# to profile javascript\\nnpm run prof\\n```\\n\",\n\n/node_modules/bower/node_modules/rimraf/node_modules/glob/README.md:\n\t29: the command line, or put `build/*` in a `.gitignore` file.\n\t101: * `man 5 gitignore`\n\n/node_modules/bower/node_modules/rimraf/node_modules/glob/node_modules/minimatch/package.json:\n\t33:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",\n\n/node_modules/bower/node_modules/rimraf/node_modules/glob/node_modules/minimatch/README.md:\n\t36: * `man 5 gitignore`\n\n/node_modules/bower/node_modules/tar-fs/test/index.js:\n\t69:   fs.symlinkSync('.gitignore', path.join(a, 'link'))\n\t79:       t.same(files[0], '.gitignore')\n\t102:   fs.symlinkSync('.gitignore', path.join(a, 'link'))\n\t112:       t.same(files[0], '.gitignore')\n\t115:       var file1 = path.join(b, '.gitignore')\n\n/node_modules/chai/History.md:\n\t533:   * Add npm-debug.log to .gitignore.\n\t916:   * update gitignore for vim *.swp\n\n/node_modules/express-validator/CHANGELOG.md:\n\t81: - [02930ff](https://github.com/ctavan/express-validator/commit/02930ff915e319b57a5a258893aaaa0d38589c7f) add .idea to .gitignore (@bars3s)\n\n/node_modules/mocha/HISTORY.md:\n\t294:  * fix: .gitignore: ignore .patch and .diff files\n\t473:  * remove test.js from .gitignore\n\n/node_modules/mocha/node_modules/glob/README.md:\n\t49: * `man 5 gitignore`\n\n/node_modules/mocha/node_modules/glob/node_modules/minimatch/README.md:\n\t38: * `man 5 gitignore`\n\n/node_modules/npm/CHANGELOG.md:\n\t852:   `.gitignore` are found and used by npm.\n\t1976:   `.npmignore` entries, `.gitignore` entries, and lifecycle scripts.\n\t5309:   install: rename .gitignore when unpacking foreign tarballs\n\t5345:   install: rename `.gitignore` when unpacking foreign tarballs\n\n/node_modules/npm/doc/files/package.json.md:\n\t184: works just like a `.gitignore`.\n\n/node_modules/npm/doc/misc/npm-developers.md:\n\t100: no `.npmignore` file, but there *is* a `.gitignore` file, then npm will\n\t101: ignore the stuff matched by the `.gitignore` file.  If you *want* to\n\t102: include something that is excluded by your `.gitignore` file, you can\n\t104: for `.npmignore` and `.gitignore` files in all subdirectories of your\n\t108: as `.gitignore` files:\n\n/node_modules/npm/html/doc/files/npm-json.html:\n\t142: works just like a <code>.gitignore</code>.</p>\n\n/node_modules/npm/html/doc/files/package.json.html:\n\t142: works just like a <code>.gitignore</code>.</p>\n\n/node_modules/npm/html/doc/misc/npm-developers.html:\n\t93: no <code>.npmignore</code> file, but there <em>is</em> a <code>.gitignore</code> file, then npm will\n\t94: ignore the stuff matched by the <code>.gitignore</code> file.  If you <em>want</em> to\n\t95: include something that is excluded by your <code>.gitignore</code> file, you can\n\t97: for <code>.npmignore</code> and <code>.gitignore</code> files in all subdirectories of your\n\t100: as <code>.gitignore</code> files:</p>\n\n/node_modules/npm/lib/utils/tar.js:\n\t325:       } else if (base === '.gitignore') {\n\t326:         var npmignore = this.path.replace(/\\.gitignore$/, '.npmignore')\n\n/node_modules/npm/man/man5/npm-json.5:\n\t223: works just like a \\fB\\|\\.gitignore\\fP\\|\\.\n\n/node_modules/npm/man/man5/package.json.5:\n\t223: works just like a \\fB\\|\\.gitignore\\fP\\|\\.\n\n/node_modules/npm/man/man7/npm-developers.7:\n\t110: no \\fB\\|\\.npmignore\\fP file, but there \\fIis\\fR a \\fB\\|\\.gitignore\\fP file, then npm will\n\t111: ignore the stuff matched by the \\fB\\|\\.gitignore\\fP file\\.  If you \\fIwant\\fR to\n\t112: include something that is excluded by your \\fB\\|\\.gitignore\\fP file, you can\n\t114: for \\fB\\|\\.npmignore\\fP and \\fB\\|\\.gitignore\\fP files in all subdirectories of your\n\t118: as \\fB\\|\\.gitignore\\fP files:\n\n/node_modules/npm/node_modules/fstream-npm/fstream-npm.js:\n\t20:                                              '.gitignore',\n\t185:   // read the .gitignore.\n\t187:     var i = entries.indexOf('.gitignore')\n\t261:   '.gitignore',\n\t293:   // if there is a .gitignore, then we're going to\n\t295:   if (entry.basename === '.gitignore') {\n\n/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/README.md:\n\t5: `.gitignore` file.\n\t12:        , ignoreFiles: [\".ignore\", \".gitignore\"]\n\t22: anything matched by the globs in any .iginore or .gitignore file.\n\n/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/example/basic.js:\n\t3:        , ignoreFiles: [\".ignore\", \".gitignore\"]\n\n/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/node_modules/minimatch/package.json:\n\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",\n\n/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/node_modules/minimatch/README.md:\n\t36: * `man 5 gitignore`\n\n/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/test/read-file-order.js:\n\t6: c.ignores({ \".gitignore\": [\"a/b/c/abc\"] })\n\t20: // Overwrite fs.readFile so that when .gitignore and .ignore are read in\n\t41:       if (filename.indexOf('.gitignore') !== -1) {\n\t62:              , ignoreFiles: [\".gitignore\", \".ignore\"] })\n\n/node_modules/npm/node_modules/glob/README.md:\n\t29: the command line, or put `build/*` in a `.gitignore` file.\n\t101: * `man 5 gitignore`\n\n/node_modules/npm/node_modules/glob/node_modules/minimatch/README.md:\n\t36: * `man 5 gitignore`\n\n/node_modules/npm/node_modules/node-gyp/node_modules/glob/package.json:\n\t45:   \"readme\": \"[![Build Status](https://travis-ci.org/isaacs/node-glob.svg?branch=master)](https://travis-ci.org/isaacs/node-glob/) [![Dependency Status](https://david-dm.org/isaacs/node-glob.svg)](https://david-dm.org/isaacs/node-glob) [![devDependency Status](https://david-dm.org/isaacs/node-glob/dev-status.svg)](https://david-dm.org/isaacs/node-glob#info=devDependencies) [![optionalDependency Status](https://david-dm.org/isaacs/node-glob/optional-status.svg)](https://david-dm.org/isaacs/node-glob#info=optionalDependencies)\\n\\n# Glob\\n\\nMatch files using the patterns the shell uses, like stars and stuff.\\n\\nThis is a glob implementation in JavaScript.  It uses the `minimatch`\\nlibrary to do its matching.\\n\\n![](oh-my-glob.gif)\\n\\n## Usage\\n\\n```javascript\\nvar glob = require(\\\"glob\\\")\\n\\n// options is optional\\nglob(\\\"**/*.js\\\", options, function (er, files) {\\n  // files is an array of filenames.\\n  // If the `nonull` option is set, and nothing\\n  // was found, then files is [\\\"**/*.js\\\"]\\n  // er is an error object or null.\\n})\\n```\\n\\n## Glob Primer\\n\\n\\\"Globs\\\" are the patterns you type when you do stuff like `ls *.js` on\\nthe command line, or put `build/*` in a `.gitignore` file.\\n\\nBefore parsing the path part patterns, braced sections are expanded\\ninto a set.  Braced sections start with `{` and end with `}`, with any\\nnumber of comma-delimited sections within.  Braced sections may contain\\nslash characters, so `a{/b/c,bcd}` would expand into `a/b/c` and `abcd`.\\n\\nThe following characters have special magic meaning when used in a\\npath portion:\\n\\n* `*` Matches 0 or more characters in a single path portion\\n* `?` Matches 1 character\\n* `[...]` Matches a range of characters, similar to a RegExp range.\\n  If the first character of the range is `!` or `^` then it matches\\n  any character not in the range.\\n* `!(pattern|pattern|pattern)` Matches anything that does not match\\n  any of the patterns provided.\\n* `?(pattern|pattern|pattern)` Matches zero or one occurrence of the\\n  patterns provided.\\n* `+(pattern|pattern|pattern)` Matches one or more occurrences of the\\n  patterns provided.\\n* `*(a|b|c)` Matches zero or more occurrences of the patterns provided\\n* `@(pattern|pat*|pat?erN)` Matches exactly one of the patterns\\n  provided\\n* `**` If a \\\"globstar\\\" is alone in a path portion, then it matches\\n  zero or more directories and subdirectories searching for matches.\\n  It does not crawl symlinked directories.\\n\\n### Dots\\n\\nIf a file or directory path portion has a `.` as the first character,\\nthen it will not match any glob pattern unless that pattern's\\ncorresponding path part also has a `.` as its first character.\\n\\nFor example, the pattern `a/.*/c` would match the file at `a/.b/c`.\\nHowever the pattern `a/*/c` would not, because `*` does not start with\\na dot character.\\n\\nYou can make glob treat dots as normal characters by setting\\n`dot:true` in the options.\\n\\n### Basename Matching\\n\\nIf you set `matchBase:true` in the options, and the pattern has no\\nslashes in it, then it will seek for any file anywhere in the tree\\nwith a matching basename.  For example, `*.js` would match\\n`test/simple/basic.js`.\\n\\n### Negation\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird, and for the time being, this should be\\navoided.  The behavior will change or be deprecated in version 5.\\n\\n### Empty Sets\\n\\nIf no matching files are found, then an empty array is returned.  This\\ndiffers from the shell, where the pattern itself is returned.  For\\nexample:\\n\\n    $ echo a*s*d*f\\n    a*s*d*f\\n\\nTo get the bash-style behavior, set the `nonull:true` in the options.\\n\\n### See Also:\\n\\n* `man sh`\\n* `man bash` (Search for \\\"Pattern Matching\\\")\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n* [minimatch documentation](https://github.com/isaacs/minimatch)\\n\\n## glob.hasMagic(pattern, [options])\\n\\nReturns `true` if there are any special characters in the pattern, and\\n`false` otherwise.\\n\\nNote that the options affect the results.  If `noext:true` is set in\\nthe options object, then `+(a|b)` will not be considered a magic\\npattern.  If the pattern has a brace expansion, like `a/{b/c,x/y}`\\nthen that is considered magical, unless `nobrace:true` is set in the\\noptions.\\n\\n## glob(pattern, [options], cb)\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* `cb` {Function}\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nPerform an asynchronous glob search.\\n\\n## glob.sync(pattern, [options])\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* return: {Array<String>} filenames found matching the pattern\\n\\nPerform a synchronous glob search.\\n\\n## Class: glob.Glob\\n\\nCreate a Glob object by instantiating the `glob.Glob` class.\\n\\n```javascript\\nvar Glob = require(\\\"glob\\\").Glob\\nvar mg = new Glob(pattern, options, cb)\\n```\\n\\nIt's an EventEmitter, and starts walking the filesystem to find matches\\nimmediately.\\n\\n### new glob.Glob(pattern, [options], [cb])\\n\\n* `pattern` {String} pattern to search for\\n* `options` {Object}\\n* `cb` {Function} Called when an error occurs, or matches are found\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nNote that if the `sync` flag is set in the options, then matches will\\nbe immediately available on the `g.found` member.\\n\\n### Properties\\n\\n* `minimatch` The minimatch object that the glob uses.\\n* `options` The options object passed in.\\n* `aborted` Boolean which is set to true when calling `abort()`.  There\\n  is no way at this time to continue a glob search after aborting, but\\n  you can re-use the statCache to avoid having to duplicate syscalls.\\n* `statCache` Collection of all the stat results the glob search\\n  performed.\\n* `cache` Convenience object.  Each field has the following possible\\n  values:\\n  * `false` - Path does not exist\\n  * `true` - Path exists\\n  * `'DIR'` - Path exists, and is not a directory\\n  * `'FILE'` - Path exists, and is a directory\\n  * `[file, entries, ...]` - Path exists, is a directory, and the\\n    array value is the results of `fs.readdir`\\n* `statCache` Cache of `fs.stat` results, to prevent statting the same\\n  path multiple times.\\n* `symlinks` A record of which paths are symbolic links, which is\\n  relevant in resolving `**` patterns.\\n* `realpathCache` An optional object which is passed to `fs.realpath`\\n  to minimize unnecessary syscalls.  It is stored on the instantiated\\n  Glob object, and may be re-used.\\n\\n### Events\\n\\n* `end` When the matching is finished, this is emitted with all the\\n  matches found.  If the `nonull` option is set, and no match was found,\\n  then the `matches` list contains the original pattern.  The matches\\n  are sorted, unless the `nosort` flag is set.\\n* `match` Every time a match is found, this is emitted with the matched.\\n* `error` Emitted when an unexpected error is encountered, or whenever\\n  any fs error occurs if `options.strict` is set.\\n* `abort` When `abort()` is called, this event is raised.\\n\\n### Methods\\n\\n* `pause` Temporarily stop the search\\n* `resume` Resume the search\\n* `abort` Stop the search forever\\n\\n### Options\\n\\nAll the options that can be passed to Minimatch can also be passed to\\nGlob to change pattern matching behavior.  Also, some have been added,\\nor have glob-specific ramifications.\\n\\nAll options are false by default, unless otherwise noted.\\n\\nAll options are added to the Glob object, as well.\\n\\nIf you are running many `glob` operations, you can pass a Glob object\\nas the `options` argument to a subsequent operation to shortcut some\\n`stat` and `readdir` calls.  At the very least, you may pass in shared\\n`symlinks`, `statCache`, `realpathCache`, and `cache` options, so that\\nparallel glob operations will be sped up by sharing information about\\nthe filesystem.\\n\\n* `cwd` The current working directory in which to search.  Defaults\\n  to `process.cwd()`.\\n* `root` The place where patterns starting with `/` will be mounted\\n  onto.  Defaults to `path.resolve(options.cwd, \\\"/\\\")` (`/` on Unix\\n  systems, and `C:\\\\` or some such on Windows.)\\n* `dot` Include `.dot` files in normal matches and `globstar` matches.\\n  Note that an explicit dot in a portion of the pattern will always\\n  match dot files.\\n* `nomount` By default, a pattern starting with a forward-slash will be\\n  \\\"mounted\\\" onto the root setting, so that a valid filesystem path is\\n  returned.  Set this flag to disable that behavior.\\n* `mark` Add a `/` character to directory matches.  Note that this\\n  requires additional stat calls.\\n* `nosort` Don't sort the results.\\n* `stat` Set to true to stat *all* results.  This reduces performance\\n  somewhat, and is completely unnecessary, unless `readdir` is presumed\\n  to be an untrustworthy indicator of file existence.\\n* `silent` When an unusual error is encountered when attempting to\\n  read a directory, a warning will be printed to stderr.  Set the\\n  `silent` option to true to suppress these warnings.\\n* `strict` When an unusual error is encountered when attempting to\\n  read a directory, the process will just continue on in search of\\n  other matches.  Set the `strict` option to raise an error in these\\n  cases.\\n* `cache` See `cache` property above.  Pass in a previously generated\\n  cache object to save some fs calls.\\n* `statCache` A cache of results of filesystem information, to prevent\\n  unnecessary stat calls.  While it should not normally be necessary\\n  to set this, you may pass the statCache from one glob() call to the\\n  options object of another, if you know that the filesystem will not\\n  change between calls.  (See \\\"Race Conditions\\\" below.)\\n* `symlinks` A cache of known symbolic links.  You may pass in a\\n  previously generated `symlinks` object to save `lstat` calls when\\n  resolving `**` matches.\\n* `sync` DEPRECATED: use `glob.sync(pattern, opts)` instead.\\n* `nounique` In some cases, brace-expanded patterns can result in the\\n  same file showing up multiple times in the result set.  By default,\\n  this implementation prevents duplicates in the result set.  Set this\\n  flag to disable that behavior.\\n* `nonull` Set to never return an empty set, instead returning a set\\n  containing the pattern itself.  This is the default in glob(3).\\n* `debug` Set to enable debug logging in minimatch and glob.\\n* `nobrace` Do not expand `{a,b}` and `{1..3}` brace sets.\\n* `noglobstar` Do not match `**` against multiple filenames.  (Ie,\\n  treat it as a normal `*` instead.)\\n* `noext` Do not match `+(a|b)` \\\"extglob\\\" patterns.\\n* `nocase` Perform a case-insensitive match.  Note: on\\n  case-insensitive filesystems, non-magic patterns will match by\\n  default, since `stat` and `readdir` will not raise errors.\\n* `matchBase` Perform a basename-only match if the pattern does not\\n  contain any slash characters.  That is, `*.js` would be treated as\\n  equivalent to `**/*.js`, matching all js files in all directories.\\n* `nonegate` Suppress `negate` behavior.  (See below.)\\n* `nocomment` Suppress `comment` behavior.  (See below.)\\n* `nonull` Return the pattern when no matches are found.\\n* `nodir` Do not match directories, only files.  (Note: to match\\n  *only* directories, simply put a `/` at the end of the pattern.)\\n* `ignore` Add a pattern or an array of patterns to exclude matches.\\n* `follow` Follow symlinked directories when expanding `**` patterns.\\n  Note that this can result in a lot of duplicate references in the\\n  presence of cyclic links.\\n* `realpath` Set to true to call `fs.realpath` on all of the results.\\n  In the case of a symlink that cannot be resolved, the full absolute\\n  path to the matched entry is returned (though it will usually be a\\n  broken symlink)\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between node-glob and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.3, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nNote that symlinked directories are not crawled as part of a `**`,\\nthough their contents may match against subsequent portions of the\\npattern.  This prevents infinite loops and duplicates and the like.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen glob returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`glob.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\\n## Windows\\n\\n**Please only use forward-slashes in glob expressions.**\\n\\nThough windows uses either `/` or `\\\\` as its path separator, only `/`\\ncharacters are used by this glob implementation.  You must use\\nforward-slashes **only** in glob expressions.  Back-slashes will always\\nbe interpreted as escape characters, not path separators.\\n\\nResults from absolute patterns such as `/foo/*` are mounted onto the\\nroot setting using `path.join`.  On windows, this will by default result\\nin `/foo/*` matching `C:\\\\foo\\\\bar.txt`.\\n\\n## Race Conditions\\n\\nGlob searching, by its very nature, is susceptible to race conditions,\\nsince it relies on directory walking and such.\\n\\nAs a result, it is possible that a file that exists when glob looks for\\nit may have been deleted or modified by the time it returns the result.\\n\\nAs part of its internal implementation, this program caches all stat\\nand readdir calls that it makes, in order to cut down on system\\noverhead.  However, this also makes it even more susceptible to races,\\nespecially if the cache or statCache objects are reused between glob\\ncalls.\\n\\nUsers are thus advised not to use a glob result as a guarantee of\\nfilesystem state in the face of rapid changes.  For the vast majority\\nof operations, this is never a problem.\\n\\n## Contributing\\n\\nAny change to behavior (including bugfixes) must come with a test.\\n\\nPatches that fail tests or reduce performance will be rejected.\\n\\n```\\n# to run tests\\nnpm test\\n\\n# to re-generate test fixtures\\nnpm run test-regen\\n\\n# to benchmark against bash/zsh\\nnpm run bench\\n\\n# to profile javascript\\nnpm run prof\\n```\\n\",\n\n/node_modules/npm/node_modules/node-gyp/node_modules/glob/README.md:\n\t29: the command line, or put `build/*` in a `.gitignore` file.\n\t100: * `man 5 gitignore`\n\n/node_modules/npm/node_modules/node-gyp/node_modules/glob/node_modules/minimatch/package.json:\n\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",\n\n/node_modules/npm/node_modules/node-gyp/node_modules/glob/node_modules/minimatch/README.md:\n\t36: * `man 5 gitignore`\n\n/node_modules/npm/node_modules/node-gyp/node_modules/minimatch/README.md:\n\t38: * `man 5 gitignore`\n\n/node_modules/npm/node_modules/validate-npm-package-license/node_modules/spdx-license-ids/package.json:\n\t15:     \"lint\": \"eslint --config node_modules/@shinnn/eslintrc/rc.json --ignore-path .gitignore .\",\n\n/node_modules/npm/test/tap/git-npmignore.js:\n\t28: var gitignore = 'node_modules/\\n'\n\t112:   cat(resolve(dep, '.gitignore'), gitignore)\n\n/node_modules/npm/test/tap/unpack-foreign-tarball.js:\n\t15: var target = path.resolve(nm, 'npm-test-gitignore')\n\t50: test('gitignore only', function (t) {\n\t52:   var file = path.resolve(fixtures, 'gitignore.tgz')\n\t56: test('gitignore and npmignore', function (t) {\n\t58:   var file = path.resolve(fixtures, 'gitignore-and-npmignore.tgz')\n\t62: test('gitignore and npmignore, not gzipped 1/2', function (t) {\n\t64:   var file = path.resolve(fixtures, 'gitignore-and-npmignore.tar')\n\t68: test('gitignore and npmignore, not gzipped 2/2', function (t) {\n\t70:   var file = path.resolve(fixtures, 'gitignore-and-npmignore-2.tar')\n\n/node_modules/waterline/node_modules/prompt/node_modules/utile/node_modules/rimraf/node_modules/glob/README.md:\n\t29: the command line, or put `build/*` in a `.gitignore` file.\n\t101: * `man 5 gitignore`\n\n/node_modules/waterline/node_modules/prompt/node_modules/utile/node_modules/rimraf/node_modules/glob/node_modules/minimatch/README.md:\n\t36: * `man 5 gitignore`\n\n/public/lib/bootswatch/bower.json:\n\t22:     \".gitignore\",\n\nFound 137 matches in 58 files \n\n","undoManager":{"mark":-2,"position":20,"stack":[[{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"insert","lines":[" "],"id":1},{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"remove","lines":[" "]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001gitignore\u0001 in\u0001/\u0001","",""]}],[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/bower_components/bootswatch/bower.json:",""],"id":2},{"start":{"row":3,"column":0},"end":{"row":5,"column":0},"action":"insert","lines":["\t22:     \".gitignore\",","",""]}],[{"start":{"row":5,"column":0},"end":{"row":8,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/fstream-ignore/package.json:","\t29:   \"readme\": \"# fstream-ignore\\n\\nA fstream DirReader that filters out files that match globs in `.ignore`\\nfiles throughout the tree, like how git ignores files based on a\\n`.gitignore` file.\\n\\nHere's an example:\\n\\n```javascript\\nvar Ignore = require(\\\"fstream-ignore\\\")\\nIgnore({ path: __dirname\\n       , ignoreFiles: [\\\".ignore\\\", \\\".gitignore\\\"]\\n       })\\n  .on(\\\"child\\\", function (c) {\\n    console.error(c.path.substr(c.root.path.length + 1))\\n  })\\n  .pipe(tar.Pack())\\n  .pipe(fs.createWriteStream(\\\"foo.tar\\\"))\\n```\\n\\nThis will tar up the files in __dirname into `foo.tar`, ignoring\\nanything matched by the globs in any .iginore or .gitignore file.\\n\",","",""],"id":3},{"start":{"row":8,"column":0},"end":{"row":13,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/fstream-ignore/README.md:","\t5: `.gitignore` file.","\t12:        , ignoreFiles: [\".ignore\", \".gitignore\"]","\t22: anything matched by the globs in any .iginore or .gitignore file.","",""]},{"start":{"row":13,"column":0},"end":{"row":14,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/fstream-ignore/example/basic.js:",""]},{"start":{"row":14,"column":0},"end":{"row":16,"column":0},"action":"insert","lines":["\t3:        , ignoreFiles: [\".ignore\", \".gitignore\"]","",""]},{"start":{"row":16,"column":0},"end":{"row":17,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/fstream-ignore/node_modules/minimatch/package.json:",""]},{"start":{"row":17,"column":0},"end":{"row":19,"column":0},"action":"insert","lines":["\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",","",""]},{"start":{"row":19,"column":0},"end":{"row":22,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/fstream-ignore/node_modules/minimatch/README.md:","\t36: * `man 5 gitignore`","",""]},{"start":{"row":22,"column":0},"end":{"row":28,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/fstream-ignore/test/read-file-order.js:","\t6: c.ignores({ \".gitignore\": [\"a/b/c/abc\"] })","\t20: // Overwrite fs.readFile so that when .gitignore and .ignore are read in","\t41:       if (filename.indexOf('.gitignore') !== -1) {","\t62:              , ignoreFiles: [\".gitignore\", \".ignore\"] })","",""]},{"start":{"row":28,"column":0},"end":{"row":29,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/package.json:",""]},{"start":{"row":29,"column":0},"end":{"row":31,"column":0},"action":"insert","lines":["\t45:   \"readme\": \"# JavaScript GitHub API for Node.JS\\n\\nA Node.JS module, which provides an object oriented wrapper for the GitHub v3 API.\\n\\n## Installation\\n\\n  Install with the Node.JS package manager [npm](http://npmjs.org/) ![NPM version](https://badge.fury.io/js/github.svg):\\n\\n      $ npm install github\\n\\nor\\n\\n  Install via git clone:\\n\\n      $ git clone git://github.com/mikedeboer/node-github.git\\n      $ cd node-github\\n      $ npm install\\n\\n## Documentation\\n\\nYou can find the docs for the API of this client at [http://mikedeboer.github.com/node-github/](http://mikedeboer.github.com/node-github/)\\n\\nAdditionally, the [official Github documentation](https://developer.github.com/v3/)\\nis a very useful resource.\\n\\n## Example\\n\\nPrint all followers of the user \\\"mikedeboer\\\" to the console.\\n```javascript\\nvar GitHubApi = require(\\\"github\\\");\\n\\nvar github = new GitHubApi({\\n    // required\\n    version: \\\"3.0.0\\\",\\n    // optional\\n    debug: true,\\n    protocol: \\\"https\\\",\\n    host: \\\"github.my-GHE-enabled-company.com\\\", // should be api.github.com for GitHub\\n    pathPrefix: \\\"/api/v3\\\", // for some GHEs; none for GitHub\\n    timeout: 5000,\\n    headers: {\\n        \\\"user-agent\\\": \\\"My-Cool-GitHub-App\\\" // GitHub is happy with a unique user agent\\n    }\\n});\\ngithub.user.getFollowingFromUser({\\n    // optional:\\n    // headers: {\\n    //     \\\"cookie\\\": \\\"blahblah\\\"\\n    // },\\n    user: \\\"mikedeboer\\\"\\n}, function(err, res) {\\n    console.log(JSON.stringify(res));\\n});\\n```\\n\\nFirst the _GitHubApi_ class is imported from the _node-github_ module. This class provides\\naccess to all of GitHub's APIs (e.g. user, issues or repo APIs). The _getFollowingFromUser_\\nmethod lists all followers of a given GitHub user. Is is part of the user API. It\\ntakes the user name as first argument and a callback as last argument. Once the\\nfollower list is returned from the server, the callback is called.\\n\\nLike in Node.JS, callbacks are always the last argument. If the functions fails an\\nerror object is passed as first argument to the callback.\\n\\n## Authentication\\n\\nMost GitHub API calls don't require authentication. As a rule of thumb: If you\\ncan see the information by visiting the site without being logged in, you don't\\nhave to be authenticated to retrieve the same information through the API. Of\\ncourse calls, which change data or read sensitive information have to be authenticated.\\n\\nYou need the GitHub user name and the API key for authentication. The API key can\\nbe found in the user's _Account Settings_ page.\\n\\nThis example shows how to authenticate and then change _location_ field of the\\naccount settings to _Argentina_:\\n```javascript\\ngithub.authenticate({\\n    type: \\\"basic\\\",\\n    username: username,\\n    password: password\\n});\\ngithub.user.update({\\n    location: \\\"Argentina\\\"\\n}, function(err) {\\n    console.log(\\\"done!\\\");\\n});\\n```\\nNote that the _authenticate_ method is synchronous because it only stores the\\ncredentials for the next request.\\n\\nOther examples for the various authentication methods:\\n```javascript\\n// OAuth2\\ngithub.authenticate({\\n    type: \\\"oauth\\\",\\n    token: token\\n});\\n\\n// OAuth2 Key/Secret\\ngithub.authenticate({\\n    type: \\\"oauth\\\",\\n    key: \\\"clientID\\\",\\n    secret: \\\"clientSecret\\\"\\n})\\n\\n// Deprecated Gihub API token (seems not to be working with the v3 API)\\ngithub.authenticate({\\n    type: \\\"token\\\",\\n    token: token\\n});\\n```\\n\\n### Creating tokens for your application\\n[Create a new authorization](http://developer.github.com/v3/oauth/#create-a-new-authorization) for your application giving it access to the wanted scopes you need instead of relying on username / password and is the way to go if you have [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) on.\\n\\nFor example:\\n\\n1. Use github.authenticate() to auth with GitHub using your username / password\\n2. Create an application token programmatically with the scopes you need and, if you use two-factor authentication send the `X-GitHub-OTP` header with the one-time-password you get on your token device.\\n\\n```javascript\\ngithub.authorization.create({\\n    scopes: [\\\"user\\\", \\\"public_repo\\\", \\\"repo\\\", \\\"repo:status\\\", \\\"gist\\\"],\\n    note: \\\"what this auth is for\\\",\\n    note_url: \\\"http://url-to-this-auth-app\\\",\\n    headers: {\\n        \\\"X-GitHub-OTP\\\": \\\"two-factor-code\\\"\\n    }\\n}, function(err, res) {\\n    if (res.token) {\\n        //save and use res.token as in the Oauth process above from now on\\n    }\\n});\\n```\\n\\n## Implemented GitHub APIs\\n\\n* Gists: 100%\\n* Git Data: 100%\\n* Issues: 100%\\n* Orgs: 100%\\n* Pull Requests: 100%\\n* Repos: 100%\\n* Users: 100%\\n* Events: 100%\\n* Search: 100%\\n* Markdown: 100%\\n* Rate Limit: 100%\\n* Releases: 100%\\n* Gitignore: 100%\\n* Meta: 100%\\n* Emojis: 100%\\n\\n## Running the Tests\\n\\nThe unit tests are based on the [mocha](http://visionmedia.github.com/mocha/)\\nmodule, which may be installed via npm. To run the tests make sure that the\\nnpm dependencies are installed by running `npm install` from the project directory.\\n\\nBefore running unit tests:\\n```shell\\nnpm install mocha -g\\n```\\nAt the moment, test classes can only be run separately. This will e.g. run the Issues Api test:\\n```shell\\nmocha api/v3.0.0/issuesTest.js\\n```\\nNote that a connection to the internet is required to run the tests.\\n\\n## LICENSE\\n\\nMIT license. See the LICENSE file for details.\\n\",","",""]},{"start":{"row":31,"column":0},"end":{"row":32,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/README.md:",""]},{"start":{"row":32,"column":0},"end":{"row":34,"column":0},"action":"insert","lines":["\t151: * Gitignore: 100%","",""]},{"start":{"row":34,"column":0},"end":{"row":35,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/api/v3.0.0/gitignore.js:",""]},{"start":{"row":35,"column":0},"end":{"row":43,"column":0},"action":"insert","lines":["\t2:  *  mixin gitignore","\t17: var gitignore = module.exports = {","\t18:     gitignore: {}","\t23:      *  gitignore#templates(msg, callback) -> null","\t68:      *  gitignore#template(msg, callback) -> null","\t75:      *  - name (String): Required. The name of the .gitignore template to get","\t112: }).call(gitignore.gitignore);","",""]},{"start":{"row":43,"column":0},"end":{"row":44,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/api/v3.0.0/gitignoreTest.js:",""]},{"start":{"row":44,"column":0},"end":{"row":50,"column":0},"action":"insert","lines":["\t15: describe(\"[gitignore]\", function() {","\t24:     it(\"should successfully execute GET /gitignore/templates (templates)\",  function(next) {","\t25:         client.gitignore.templates(","\t38:     it(\"should successfully execute GET /gitignore/templates/:name (template)\",  function(next) {","\t39:         client.gitignore.template(","",""]},{"start":{"row":50,"column":0},"end":{"row":51,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/api/v3.0.0/index.js:",""]},{"start":{"row":51,"column":0},"end":{"row":53,"column":0},"action":"insert","lines":["\t36: [\"gists\", \"gitdata\", \"issues\", \"authorization\", \"orgs\", \"statuses\", \"pullRequests\", \"repos\", \"user\", \"events\", \"releases\", \"search\", \"markdown\", \"gitignore\", \"misc\"].forEach(function(api) {","",""]}],[{"start":{"row":53,"column":0},"end":{"row":54,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/api/v3.0.0/repos.js:",""],"id":4},{"start":{"row":54,"column":0},"end":{"row":57,"column":0},"action":"insert","lines":["\t185:      *  - gitignore_template (String): Optional. Desired language or platform .gitignore template to apply. Ignored if auto_init parameter is not provided.","\t239:      *  - gitignore_template (String): Optional. Desired language or platform .gitignore template to apply. Ignored if auto_init parameter is not provided.","",""]},{"start":{"row":57,"column":0},"end":{"row":61,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/api/v3.0.0/reposTest.js:","\t91:                 gitignore_template: \"String\"","\t113:                 gitignore_template: \"String\",","",""]},{"start":{"row":61,"column":0},"end":{"row":62,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/github/api/v3.0.0/routes.json:",""]},{"start":{"row":62,"column":0},"end":{"row":71,"column":0},"action":"insert","lines":["\t313:             \"gitignore_template\": {","\t318:                 \"description\": \"Desired language or platform .gitignore template to apply. Ignored if auto_init parameter is not provided.\"","\t1963:                 \"$gitignore_template\": null","\t1980:                 \"$gitignore_template\": null,","\t3876:     \"gitignore\": {","\t3878:             \"url\": \"/gitignore/templates\",","\t3883:             \"url\": \"/gitignore/templates/:name\",","\t3891:                     \"description\": \"The name of the .gitignore template to get\"","",""]},{"start":{"row":71,"column":0},"end":{"row":72,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/glob/package.json:",""]},{"start":{"row":72,"column":0},"end":{"row":74,"column":0},"action":"insert","lines":["\t45:   \"readme\": \"[![Build Status](https://travis-ci.org/isaacs/node-glob.svg?branch=master)](https://travis-ci.org/isaacs/node-glob/) [![Dependency Status](https://david-dm.org/isaacs/node-glob.svg)](https://david-dm.org/isaacs/node-glob) [![devDependency Status](https://david-dm.org/isaacs/node-glob/dev-status.svg)](https://david-dm.org/isaacs/node-glob#info=devDependencies) [![optionalDependency Status](https://david-dm.org/isaacs/node-glob/optional-status.svg)](https://david-dm.org/isaacs/node-glob#info=optionalDependencies)\\n\\n# Glob\\n\\nMatch files using the patterns the shell uses, like stars and stuff.\\n\\nThis is a glob implementation in JavaScript.  It uses the `minimatch`\\nlibrary to do its matching.\\n\\n![](oh-my-glob.gif)\\n\\n## Usage\\n\\n```javascript\\nvar glob = require(\\\"glob\\\")\\n\\n// options is optional\\nglob(\\\"**/*.js\\\", options, function (er, files) {\\n  // files is an array of filenames.\\n  // If the `nonull` option is set, and nothing\\n  // was found, then files is [\\\"**/*.js\\\"]\\n  // er is an error object or null.\\n})\\n```\\n\\n## Glob Primer\\n\\n\\\"Globs\\\" are the patterns you type when you do stuff like `ls *.js` on\\nthe command line, or put `build/*` in a `.gitignore` file.\\n\\nBefore parsing the path part patterns, braced sections are expanded\\ninto a set.  Braced sections start with `{` and end with `}`, with any\\nnumber of comma-delimited sections within.  Braced sections may contain\\nslash characters, so `a{/b/c,bcd}` would expand into `a/b/c` and `abcd`.\\n\\nThe following characters have special magic meaning when used in a\\npath portion:\\n\\n* `*` Matches 0 or more characters in a single path portion\\n* `?` Matches 1 character\\n* `[...]` Matches a range of characters, similar to a RegExp range.\\n  If the first character of the range is `!` or `^` then it matches\\n  any character not in the range.\\n* `!(pattern|pattern|pattern)` Matches anything that does not match\\n  any of the patterns provided.\\n* `?(pattern|pattern|pattern)` Matches zero or one occurrence of the\\n  patterns provided.\\n* `+(pattern|pattern|pattern)` Matches one or more occurrences of the\\n  patterns provided.\\n* `*(a|b|c)` Matches zero or more occurrences of the patterns provided\\n* `@(pattern|pat*|pat?erN)` Matches exactly one of the patterns\\n  provided\\n* `**` If a \\\"globstar\\\" is alone in a path portion, then it matches\\n  zero or more directories and subdirectories searching for matches.\\n  It does not crawl symlinked directories.\\n\\n### Dots\\n\\nIf a file or directory path portion has a `.` as the first character,\\nthen it will not match any glob pattern unless that pattern's\\ncorresponding path part also has a `.` as its first character.\\n\\nFor example, the pattern `a/.*/c` would match the file at `a/.b/c`.\\nHowever the pattern `a/*/c` would not, because `*` does not start with\\na dot character.\\n\\nYou can make glob treat dots as normal characters by setting\\n`dot:true` in the options.\\n\\n### Basename Matching\\n\\nIf you set `matchBase:true` in the options, and the pattern has no\\nslashes in it, then it will seek for any file anywhere in the tree\\nwith a matching basename.  For example, `*.js` would match\\n`test/simple/basic.js`.\\n\\n### Negation\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird, and for the time being, this should be\\navoided.  The behavior will change or be deprecated in version 5.\\n\\n### Empty Sets\\n\\nIf no matching files are found, then an empty array is returned.  This\\ndiffers from the shell, where the pattern itself is returned.  For\\nexample:\\n\\n    $ echo a*s*d*f\\n    a*s*d*f\\n\\nTo get the bash-style behavior, set the `nonull:true` in the options.\\n\\n### See Also:\\n\\n* `man sh`\\n* `man bash` (Search for \\\"Pattern Matching\\\")\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n* [minimatch documentation](https://github.com/isaacs/minimatch)\\n\\n## glob.hasMagic(pattern, [options])\\n\\nReturns `true` if there are any special characters in the pattern, and\\n`false` otherwise.\\n\\nNote that the options affect the results.  If `noext:true` is set in\\nthe options object, then `+(a|b)` will not be considered a magic\\npattern.  If the pattern has a brace expansion, like `a/{b/c,x/y}`\\nthen that is considered magical, unless `nobrace:true` is set in the\\noptions.\\n\\n## glob(pattern, [options], cb)\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* `cb` {Function}\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nPerform an asynchronous glob search.\\n\\n## glob.sync(pattern, [options])\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* return: {Array<String>} filenames found matching the pattern\\n\\nPerform a synchronous glob search.\\n\\n## Class: glob.Glob\\n\\nCreate a Glob object by instantiating the `glob.Glob` class.\\n\\n```javascript\\nvar Glob = require(\\\"glob\\\").Glob\\nvar mg = new Glob(pattern, options, cb)\\n```\\n\\nIt's an EventEmitter, and starts walking the filesystem to find matches\\nimmediately.\\n\\n### new glob.Glob(pattern, [options], [cb])\\n\\n* `pattern` {String} pattern to search for\\n* `options` {Object}\\n* `cb` {Function} Called when an error occurs, or matches are found\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nNote that if the `sync` flag is set in the options, then matches will\\nbe immediately available on the `g.found` member.\\n\\n### Properties\\n\\n* `minimatch` The minimatch object that the glob uses.\\n* `options` The options object passed in.\\n* `aborted` Boolean which is set to true when calling `abort()`.  There\\n  is no way at this time to continue a glob search after aborting, but\\n  you can re-use the statCache to avoid having to duplicate syscalls.\\n* `statCache` Collection of all the stat results the glob search\\n  performed.\\n* `cache` Convenience object.  Each field has the following possible\\n  values:\\n  * `false` - Path does not exist\\n  * `true` - Path exists\\n  * `'DIR'` - Path exists, and is not a directory\\n  * `'FILE'` - Path exists, and is a directory\\n  * `[file, entries, ...]` - Path exists, is a directory, and the\\n    array value is the results of `fs.readdir`\\n* `statCache` Cache of `fs.stat` results, to prevent statting the same\\n  path multiple times.\\n* `symlinks` A record of which paths are symbolic links, which is\\n  relevant in resolving `**` patterns.\\n* `realpathCache` An optional object which is passed to `fs.realpath`\\n  to minimize unnecessary syscalls.  It is stored on the instantiated\\n  Glob object, and may be re-used.\\n\\n### Events\\n\\n* `end` When the matching is finished, this is emitted with all the\\n  matches found.  If the `nonull` option is set, and no match was found,\\n  then the `matches` list contains the original pattern.  The matches\\n  are sorted, unless the `nosort` flag is set.\\n* `match` Every time a match is found, this is emitted with the matched.\\n* `error` Emitted when an unexpected error is encountered, or whenever\\n  any fs error occurs if `options.strict` is set.\\n* `abort` When `abort()` is called, this event is raised.\\n\\n### Methods\\n\\n* `pause` Temporarily stop the search\\n* `resume` Resume the search\\n* `abort` Stop the search forever\\n\\n### Options\\n\\nAll the options that can be passed to Minimatch can also be passed to\\nGlob to change pattern matching behavior.  Also, some have been added,\\nor have glob-specific ramifications.\\n\\nAll options are false by default, unless otherwise noted.\\n\\nAll options are added to the Glob object, as well.\\n\\nIf you are running many `glob` operations, you can pass a Glob object\\nas the `options` argument to a subsequent operation to shortcut some\\n`stat` and `readdir` calls.  At the very least, you may pass in shared\\n`symlinks`, `statCache`, `realpathCache`, and `cache` options, so that\\nparallel glob operations will be sped up by sharing information about\\nthe filesystem.\\n\\n* `cwd` The current working directory in which to search.  Defaults\\n  to `process.cwd()`.\\n* `root` The place where patterns starting with `/` will be mounted\\n  onto.  Defaults to `path.resolve(options.cwd, \\\"/\\\")` (`/` on Unix\\n  systems, and `C:\\\\` or some such on Windows.)\\n* `dot` Include `.dot` files in normal matches and `globstar` matches.\\n  Note that an explicit dot in a portion of the pattern will always\\n  match dot files.\\n* `nomount` By default, a pattern starting with a forward-slash will be\\n  \\\"mounted\\\" onto the root setting, so that a valid filesystem path is\\n  returned.  Set this flag to disable that behavior.\\n* `mark` Add a `/` character to directory matches.  Note that this\\n  requires additional stat calls.\\n* `nosort` Don't sort the results.\\n* `stat` Set to true to stat *all* results.  This reduces performance\\n  somewhat, and is completely unnecessary, unless `readdir` is presumed\\n  to be an untrustworthy indicator of file existence.\\n* `silent` When an unusual error is encountered when attempting to\\n  read a directory, a warning will be printed to stderr.  Set the\\n  `silent` option to true to suppress these warnings.\\n* `strict` When an unusual error is encountered when attempting to\\n  read a directory, the process will just continue on in search of\\n  other matches.  Set the `strict` option to raise an error in these\\n  cases.\\n* `cache` See `cache` property above.  Pass in a previously generated\\n  cache object to save some fs calls.\\n* `statCache` A cache of results of filesystem information, to prevent\\n  unnecessary stat calls.  While it should not normally be necessary\\n  to set this, you may pass the statCache from one glob() call to the\\n  options object of another, if you know that the filesystem will not\\n  change between calls.  (See \\\"Race Conditions\\\" below.)\\n* `symlinks` A cache of known symbolic links.  You may pass in a\\n  previously generated `symlinks` object to save `lstat` calls when\\n  resolving `**` matches.\\n* `sync` DEPRECATED: use `glob.sync(pattern, opts)` instead.\\n* `nounique` In some cases, brace-expanded patterns can result in the\\n  same file showing up multiple times in the result set.  By default,\\n  this implementation prevents duplicates in the result set.  Set this\\n  flag to disable that behavior.\\n* `nonull` Set to never return an empty set, instead returning a set\\n  containing the pattern itself.  This is the default in glob(3).\\n* `debug` Set to enable debug logging in minimatch and glob.\\n* `nobrace` Do not expand `{a,b}` and `{1..3}` brace sets.\\n* `noglobstar` Do not match `**` against multiple filenames.  (Ie,\\n  treat it as a normal `*` instead.)\\n* `noext` Do not match `+(a|b)` \\\"extglob\\\" patterns.\\n* `nocase` Perform a case-insensitive match.  Note: on\\n  case-insensitive filesystems, non-magic patterns will match by\\n  default, since `stat` and `readdir` will not raise errors.\\n* `matchBase` Perform a basename-only match if the pattern does not\\n  contain any slash characters.  That is, `*.js` would be treated as\\n  equivalent to `**/*.js`, matching all js files in all directories.\\n* `nonegate` Suppress `negate` behavior.  (See below.)\\n* `nocomment` Suppress `comment` behavior.  (See below.)\\n* `nonull` Return the pattern when no matches are found.\\n* `nodir` Do not match directories, only files.  (Note: to match\\n  *only* directories, simply put a `/` at the end of the pattern.)\\n* `ignore` Add a pattern or an array of patterns to exclude matches.\\n* `follow` Follow symlinked directories when expanding `**` patterns.\\n  Note that this can result in a lot of duplicate references in the\\n  presence of cyclic links.\\n* `realpath` Set to true to call `fs.realpath` on all of the results.\\n  In the case of a symlink that cannot be resolved, the full absolute\\n  path to the matched entry is returned (though it will usually be a\\n  broken symlink)\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between node-glob and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.3, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nNote that symlinked directories are not crawled as part of a `**`,\\nthough their contents may match against subsequent portions of the\\npattern.  This prevents infinite loops and duplicates and the like.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen glob returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`glob.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\\n## Windows\\n\\n**Please only use forward-slashes in glob expressions.**\\n\\nThough windows uses either `/` or `\\\\` as its path separator, only `/`\\ncharacters are used by this glob implementation.  You must use\\nforward-slashes **only** in glob expressions.  Back-slashes will always\\nbe interpreted as escape characters, not path separators.\\n\\nResults from absolute patterns such as `/foo/*` are mounted onto the\\nroot setting using `path.join`.  On windows, this will by default result\\nin `/foo/*` matching `C:\\\\foo\\\\bar.txt`.\\n\\n## Race Conditions\\n\\nGlob searching, by its very nature, is susceptible to race conditions,\\nsince it relies on directory walking and such.\\n\\nAs a result, it is possible that a file that exists when glob looks for\\nit may have been deleted or modified by the time it returns the result.\\n\\nAs part of its internal implementation, this program caches all stat\\nand readdir calls that it makes, in order to cut down on system\\noverhead.  However, this also makes it even more susceptible to races,\\nespecially if the cache or statCache objects are reused between glob\\ncalls.\\n\\nUsers are thus advised not to use a glob result as a guarantee of\\nfilesystem state in the face of rapid changes.  For the vast majority\\nof operations, this is never a problem.\\n\\n## Contributing\\n\\nAny change to behavior (including bugfixes) must come with a test.\\n\\nPatches that fail tests or reduce performance will be rejected.\\n\\n```\\n# to run tests\\nnpm test\\n\\n# to re-generate test fixtures\\nnpm run test-regen\\n\\n# to benchmark against bash/zsh\\nnpm run bench\\n\\n# to profile javascript\\nnpm run prof\\n```\\n\",","",""]},{"start":{"row":74,"column":0},"end":{"row":78,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/glob/README.md:","\t29: the command line, or put `build/*` in a `.gitignore` file.","\t100: * `man 5 gitignore`","",""]},{"start":{"row":78,"column":0},"end":{"row":79,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/glob/node_modules/minimatch/package.json:",""]},{"start":{"row":79,"column":0},"end":{"row":82,"column":0},"action":"insert","lines":["\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",","","/node_modules/bower/node_modules/glob/node_modules/minimatch/README.md:",""]},{"start":{"row":82,"column":0},"end":{"row":84,"column":0},"action":"insert","lines":["\t36: * `man 5 gitignore`","",""]}],[{"start":{"row":84,"column":0},"end":{"row":85,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/rimraf/node_modules/glob/package.json:",""],"id":5}],[{"start":{"row":85,"column":0},"end":{"row":91,"column":0},"action":"insert","lines":["\t46:   \"readme\": \"[![Build Status](https://travis-ci.org/isaacs/node-glob.svg?branch=master)](https://travis-ci.org/isaacs/node-glob/) [![Dependency Status](https://david-dm.org/isaacs/node-glob.svg)](https://david-dm.org/isaacs/node-glob) [![devDependency Status](https://david-dm.org/isaacs/node-glob/dev-status.svg)](https://david-dm.org/isaacs/node-glob#info=devDependencies) [![optionalDependency Status](https://david-dm.org/isaacs/node-glob/optional-status.svg)](https://david-dm.org/isaacs/node-glob#info=optionalDependencies)\\n\\n# Glob\\n\\nMatch files using the patterns the shell uses, like stars and stuff.\\n\\nThis is a glob implementation in JavaScript.  It uses the `minimatch`\\nlibrary to do its matching.\\n\\n![](oh-my-glob.gif)\\n\\n## Usage\\n\\n```javascript\\nvar glob = require(\\\"glob\\\")\\n\\n// options is optional\\nglob(\\\"**/*.js\\\", options, function (er, files) {\\n  // files is an array of filenames.\\n  // If the `nonull` option is set, and nothing\\n  // was found, then files is [\\\"**/*.js\\\"]\\n  // er is an error object or null.\\n})\\n```\\n\\n## Glob Primer\\n\\n\\\"Globs\\\" are the patterns you type when you do stuff like `ls *.js` on\\nthe command line, or put `build/*` in a `.gitignore` file.\\n\\nBefore parsing the path part patterns, braced sections are expanded\\ninto a set.  Braced sections start with `{` and end with `}`, with any\\nnumber of comma-delimited sections within.  Braced sections may contain\\nslash characters, so `a{/b/c,bcd}` would expand into `a/b/c` and `abcd`.\\n\\nThe following characters have special magic meaning when used in a\\npath portion:\\n\\n* `*` Matches 0 or more characters in a single path portion\\n* `?` Matches 1 character\\n* `[...]` Matches a range of characters, similar to a RegExp range.\\n  If the first character of the range is `!` or `^` then it matches\\n  any character not in the range.\\n* `!(pattern|pattern|pattern)` Matches anything that does not match\\n  any of the patterns provided.\\n* `?(pattern|pattern|pattern)` Matches zero or one occurrence of the\\n  patterns provided.\\n* `+(pattern|pattern|pattern)` Matches one or more occurrences of the\\n  patterns provided.\\n* `*(a|b|c)` Matches zero or more occurrences of the patterns provided\\n* `@(pattern|pat*|pat?erN)` Matches exactly one of the patterns\\n  provided\\n* `**` If a \\\"globstar\\\" is alone in a path portion, then it matches\\n  zero or more directories and subdirectories searching for matches.\\n  It does not crawl symlinked directories.\\n\\n### Dots\\n\\nIf a file or directory path portion has a `.` as the first character,\\nthen it will not match any glob pattern unless that pattern's\\ncorresponding path part also has a `.` as its first character.\\n\\nFor example, the pattern `a/.*/c` would match the file at `a/.b/c`.\\nHowever the pattern `a/*/c` would not, because `*` does not start with\\na dot character.\\n\\nYou can make glob treat dots as normal characters by setting\\n`dot:true` in the options.\\n\\n### Basename Matching\\n\\nIf you set `matchBase:true` in the options, and the pattern has no\\nslashes in it, then it will seek for any file anywhere in the tree\\nwith a matching basename.  For example, `*.js` would match\\n`test/simple/basic.js`.\\n\\n### Negation\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird, and for the time being, this should be\\navoided.  The behavior is deprecated in version 5, and will be removed\\nentirely in version 6.\\n\\n### Empty Sets\\n\\nIf no matching files are found, then an empty array is returned.  This\\ndiffers from the shell, where the pattern itself is returned.  For\\nexample:\\n\\n    $ echo a*s*d*f\\n    a*s*d*f\\n\\nTo get the bash-style behavior, set the `nonull:true` in the options.\\n\\n### See Also:\\n\\n* `man sh`\\n* `man bash` (Search for \\\"Pattern Matching\\\")\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n* [minimatch documentation](https://github.com/isaacs/minimatch)\\n\\n## glob.hasMagic(pattern, [options])\\n\\nReturns `true` if there are any special characters in the pattern, and\\n`false` otherwise.\\n\\nNote that the options affect the results.  If `noext:true` is set in\\nthe options object, then `+(a|b)` will not be considered a magic\\npattern.  If the pattern has a brace expansion, like `a/{b/c,x/y}`\\nthen that is considered magical, unless `nobrace:true` is set in the\\noptions.\\n\\n## glob(pattern, [options], cb)\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* `cb` {Function}\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nPerform an asynchronous glob search.\\n\\n## glob.sync(pattern, [options])\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* return: {Array<String>} filenames found matching the pattern\\n\\nPerform a synchronous glob search.\\n\\n## Class: glob.Glob\\n\\nCreate a Glob object by instantiating the `glob.Glob` class.\\n\\n```javascript\\nvar Glob = require(\\\"glob\\\").Glob\\nvar mg = new Glob(pattern, options, cb)\\n```\\n\\nIt's an EventEmitter, and starts walking the filesystem to find matches\\nimmediately.\\n\\n### new glob.Glob(pattern, [options], [cb])\\n\\n* `pattern` {String} pattern to search for\\n* `options` {Object}\\n* `cb` {Function} Called when an error occurs, or matches are found\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nNote that if the `sync` flag is set in the options, then matches will\\nbe immediately available on the `g.found` member.\\n\\n### Properties\\n\\n* `minimatch` The minimatch object that the glob uses.\\n* `options` The options object passed in.\\n* `aborted` Boolean which is set to true when calling `abort()`.  There\\n  is no way at this time to continue a glob search after aborting, but\\n  you can re-use the statCache to avoid having to duplicate syscalls.\\n* `cache` Convenience object.  Each field has the following possible\\n  values:\\n  * `false` - Path does not exist\\n  * `true` - Path exists\\n  * `'DIR'` - Path exists, and is not a directory\\n  * `'FILE'` - Path exists, and is a directory\\n  * `[file, entries, ...]` - Path exists, is a directory, and the\\n    array value is the results of `fs.readdir`\\n* `statCache` Cache of `fs.stat` results, to prevent statting the same\\n  path multiple times.\\n* `symlinks` A record of which paths are symbolic links, which is\\n  relevant in resolving `**` patterns.\\n* `realpathCache` An optional object which is passed to `fs.realpath`\\n  to minimize unnecessary syscalls.  It is stored on the instantiated\\n  Glob object, and may be re-used.\\n\\n### Events\\n\\n* `end` When the matching is finished, this is emitted with all the\\n  matches found.  If the `nonull` option is set, and no match was found,\\n  then the `matches` list contains the original pattern.  The matches\\n  are sorted, unless the `nosort` flag is set.\\n* `match` Every time a match is found, this is emitted with the matched.\\n* `error` Emitted when an unexpected error is encountered, or whenever\\n  any fs error occurs if `options.strict` is set.\\n* `abort` When `abort()` is called, this event is raised.\\n\\n### Methods\\n\\n* `pause` Temporarily stop the search\\n* `resume` Resume the search\\n* `abort` Stop the search forever\\n\\n### Options\\n\\nAll the options that can be passed to Minimatch can also be passed to\\nGlob to change pattern matching behavior.  Also, some have been added,\\nor have glob-specific ramifications.\\n\\nAll options are false by default, unless otherwise noted.\\n\\nAll options are added to the Glob object, as well.\\n\\nIf you are running many `glob` operations, you can pass a Glob object\\nas the `options` argument to a subsequent operation to shortcut some\\n`stat` and `readdir` calls.  At the very least, you may pass in shared\\n`symlinks`, `statCache`, `realpathCache`, and `cache` options, so that\\nparallel glob operations will be sped up by sharing information about\\nthe filesystem.\\n\\n* `cwd` The current working directory in which to search.  Defaults\\n  to `process.cwd()`.\\n* `root` The place where patterns starting with `/` will be mounted\\n  onto.  Defaults to `path.resolve(options.cwd, \\\"/\\\")` (`/` on Unix\\n  systems, and `C:\\\\` or some such on Windows.)\\n* `dot` Include `.dot` files in normal matches and `globstar` matches.\\n  Note that an explicit dot in a portion of the pattern will always\\n  match dot files.\\n* `nomount` By default, a pattern starting with a forward-slash will be\\n  \\\"mounted\\\" onto the root setting, so that a valid filesystem path is\\n  returned.  Set this flag to disable that behavior.\\n* `mark` Add a `/` character to directory matches.  Note that this\\n  requires additional stat calls.\\n* `nosort` Don't sort the results.\\n* `stat` Set to true to stat *all* results.  This reduces performance\\n  somewhat, and is completely unnecessary, unless `readdir` is presumed\\n  to be an untrustworthy indicator of file existence.\\n* `silent` When an unusual error is encountered when attempting to\\n  read a directory, a warning will be printed to stderr.  Set the\\n  `silent` option to true to suppress these warnings.\\n* `strict` When an unusual error is encountered when attempting to\\n  read a directory, the process will just continue on in search of\\n  other matches.  Set the `strict` option to raise an error in these\\n  cases.\\n* `cache` See `cache` property above.  Pass in a previously generated\\n  cache object to save some fs calls.\\n* `statCache` A cache of results of filesystem information, to prevent\\n  unnecessary stat calls.  While it should not normally be necessary\\n  to set this, you may pass the statCache from one glob() call to the\\n  options object of another, if you know that the filesystem will not\\n  change between calls.  (See \\\"Race Conditions\\\" below.)\\n* `symlinks` A cache of known symbolic links.  You may pass in a\\n  previously generated `symlinks` object to save `lstat` calls when\\n  resolving `**` matches.\\n* `sync` DEPRECATED: use `glob.sync(pattern, opts)` instead.\\n* `nounique` In some cases, brace-expanded patterns can result in the\\n  same file showing up multiple times in the result set.  By default,\\n  this implementation prevents duplicates in the result set.  Set this\\n  flag to disable that behavior.\\n* `nonull` Set to never return an empty set, instead returning a set\\n  containing the pattern itself.  This is the default in glob(3).\\n* `debug` Set to enable debug logging in minimatch and glob.\\n* `nobrace` Do not expand `{a,b}` and `{1..3}` brace sets.\\n* `noglobstar` Do not match `**` against multiple filenames.  (Ie,\\n  treat it as a normal `*` instead.)\\n* `noext` Do not match `+(a|b)` \\\"extglob\\\" patterns.\\n* `nocase` Perform a case-insensitive match.  Note: on\\n  case-insensitive filesystems, non-magic patterns will match by\\n  default, since `stat` and `readdir` will not raise errors.\\n* `matchBase` Perform a basename-only match if the pattern does not\\n  contain any slash characters.  That is, `*.js` would be treated as\\n  equivalent to `**/*.js`, matching all js files in all directories.\\n* `nodir` Do not match directories, only files.  (Note: to match\\n  *only* directories, simply put a `/` at the end of the pattern.)\\n* `ignore` Add a pattern or an array of patterns to exclude matches.\\n* `follow` Follow symlinked directories when expanding `**` patterns.\\n  Note that this can result in a lot of duplicate references in the\\n  presence of cyclic links.\\n* `realpath` Set to true to call `fs.realpath` on all of the results.\\n  In the case of a symlink that cannot be resolved, the full absolute\\n  path to the matched entry is returned (though it will usually be a\\n  broken symlink)\\n* `nonegate` Suppress deprecated `negate` behavior.  (See below.)\\n  Default=true\\n* `nocomment` Suppress deprecated `comment` behavior.  (See below.)\\n  Default=true\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between node-glob and other\\nimplementations, and are intentional.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.3, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nNote that symlinked directories are not crawled as part of a `**`,\\nthough their contents may match against subsequent portions of the\\npattern.  This prevents infinite loops and duplicates and the like.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen glob returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`glob.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\\n### Comments and Negation\\n\\n**Note**: In version 5 of this module, negation and comments are\\n**disabled** by default.  You can explicitly set `nonegate:false` or\\n`nocomment:false` to re-enable them.  They are going away entirely in\\nversion 6.\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird.  It is better to use the `ignore` option\\nto set a pattern or set of patterns to exclude from matches.  If you\\nwant the \\\"everything except *x*\\\" type of behavior, you can use `**` as\\nthe main pattern, and set an `ignore` for the things to exclude.\\n\\nThe comments feature is added in minimatch, primarily to more easily\\nsupport use cases like ignore files, where a `#` at the start of a\\nline makes the pattern \\\"empty\\\".  However, in the context of a\\nstraightforward filesystem globber, \\\"comments\\\" don't make much sense.\\n\\n## Windows\\n\\n**Please only use forward-slashes in glob expressions.**\\n\\nThough windows uses either `/` or `\\\\` as its path separator, only `/`\\ncharacters are used by this glob implementation.  You must use\\nforward-slashes **only** in glob expressions.  Back-slashes will always\\nbe interpreted as escape characters, not path separators.\\n\\nResults from absolute patterns such as `/foo/*` are mounted onto the\\nroot setting using `path.join`.  On windows, this will by default result\\nin `/foo/*` matching `C:\\\\foo\\\\bar.txt`.\\n\\n## Race Conditions\\n\\nGlob searching, by its very nature, is susceptible to race conditions,\\nsince it relies on directory walking and such.\\n\\nAs a result, it is possible that a file that exists when glob looks for\\nit may have been deleted or modified by the time it returns the result.\\n\\nAs part of its internal implementation, this program caches all stat\\nand readdir calls that it makes, in order to cut down on system\\noverhead.  However, this also makes it even more susceptible to races,\\nespecially if the cache or statCache objects are reused between glob\\ncalls.\\n\\nUsers are thus advised not to use a glob result as a guarantee of\\nfilesystem state in the face of rapid changes.  For the vast majority\\nof operations, this is never a problem.\\n\\n## Contributing\\n\\nAny change to behavior (including bugfixes) must come with a test.\\n\\nPatches that fail tests or reduce performance will be rejected.\\n\\n```\\n# to run tests\\nnpm test\\n\\n# to re-generate test fixtures\\nnpm run test-regen\\n\\n# to benchmark against bash/zsh\\nnpm run bench\\n\\n# to profile javascript\\nnpm run prof\\n```\\n\",","","/node_modules/bower/node_modules/rimraf/node_modules/glob/README.md:","\t29: the command line, or put `build/*` in a `.gitignore` file.","\t101: * `man 5 gitignore`","",""],"id":6},{"start":{"row":91,"column":0},"end":{"row":92,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/rimraf/node_modules/glob/node_modules/minimatch/package.json:",""]},{"start":{"row":92,"column":0},"end":{"row":97,"column":0},"action":"insert","lines":["\t33:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",","","/node_modules/bower/node_modules/rimraf/node_modules/glob/node_modules/minimatch/README.md:","\t36: * `man 5 gitignore`","",""]}],[{"start":{"row":97,"column":0},"end":{"row":98,"column":0},"action":"insert","lines":["/node_modules/bower/node_modules/tar-fs/test/index.js:",""],"id":7},{"start":{"row":98,"column":0},"end":{"row":104,"column":0},"action":"insert","lines":["\t69:   fs.symlinkSync('.gitignore', path.join(a, 'link'))","\t79:       t.same(files[0], '.gitignore')","\t102:   fs.symlinkSync('.gitignore', path.join(a, 'link'))","\t112:       t.same(files[0], '.gitignore')","\t115:       var file1 = path.join(b, '.gitignore')","",""]}],[{"start":{"row":104,"column":0},"end":{"row":105,"column":0},"action":"insert","lines":["/node_modules/chai/History.md:",""],"id":8},{"start":{"row":105,"column":0},"end":{"row":108,"column":0},"action":"insert","lines":["\t533:   * Add npm-debug.log to .gitignore.","\t916:   * update gitignore for vim *.swp","",""]},{"start":{"row":108,"column":0},"end":{"row":109,"column":0},"action":"insert","lines":["/node_modules/express-validator/CHANGELOG.md:",""]},{"start":{"row":109,"column":0},"end":{"row":111,"column":0},"action":"insert","lines":["\t81: - [02930ff](https://github.com/ctavan/express-validator/commit/02930ff915e319b57a5a258893aaaa0d38589c7f) add .idea to .gitignore (@bars3s)","",""]}],[{"start":{"row":111,"column":0},"end":{"row":115,"column":0},"action":"insert","lines":["/node_modules/mocha/HISTORY.md:","\t294:  * fix: .gitignore: ignore .patch and .diff files","\t473:  * remove test.js from .gitignore","",""],"id":9}],[{"start":{"row":115,"column":0},"end":{"row":118,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/README.md:","\t49: * `man 5 gitignore`","",""],"id":10},{"start":{"row":118,"column":0},"end":{"row":121,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/node_modules/minimatch/README.md:","\t38: * `man 5 gitignore`","",""]}],[{"start":{"row":121,"column":0},"end":{"row":127,"column":0},"action":"insert","lines":["/node_modules/npm/CHANGELOG.md:","\t852:   `.gitignore` are found and used by npm.","\t1976:   `.npmignore` entries, `.gitignore` entries, and lifecycle scripts.","\t5309:   install: rename .gitignore when unpacking foreign tarballs","\t5345:   install: rename `.gitignore` when unpacking foreign tarballs","",""],"id":11},{"start":{"row":127,"column":0},"end":{"row":128,"column":0},"action":"insert","lines":["/node_modules/npm/doc/files/package.json.md:",""]},{"start":{"row":128,"column":0},"end":{"row":130,"column":0},"action":"insert","lines":["\t184: works just like a `.gitignore`.","",""]},{"start":{"row":130,"column":0},"end":{"row":137,"column":0},"action":"insert","lines":["/node_modules/npm/doc/misc/npm-developers.md:","\t100: no `.npmignore` file, but there *is* a `.gitignore` file, then npm will","\t101: ignore the stuff matched by the `.gitignore` file.  If you *want* to","\t102: include something that is excluded by your `.gitignore` file, you can","\t104: for `.npmignore` and `.gitignore` files in all subdirectories of your","\t108: as `.gitignore` files:","",""]},{"start":{"row":137,"column":0},"end":{"row":138,"column":0},"action":"insert","lines":["/node_modules/npm/html/doc/files/npm-json.html:",""]},{"start":{"row":138,"column":0},"end":{"row":140,"column":0},"action":"insert","lines":["\t142: works just like a <code>.gitignore</code>.</p>","",""]},{"start":{"row":140,"column":0},"end":{"row":141,"column":0},"action":"insert","lines":["/node_modules/npm/html/doc/files/package.json.html:",""]},{"start":{"row":141,"column":0},"end":{"row":143,"column":0},"action":"insert","lines":["\t142: works just like a <code>.gitignore</code>.</p>","",""]},{"start":{"row":143,"column":0},"end":{"row":144,"column":0},"action":"insert","lines":["/node_modules/npm/html/doc/misc/npm-developers.html:",""]},{"start":{"row":144,"column":0},"end":{"row":150,"column":0},"action":"insert","lines":["\t93: no <code>.npmignore</code> file, but there <em>is</em> a <code>.gitignore</code> file, then npm will","\t94: ignore the stuff matched by the <code>.gitignore</code> file.  If you <em>want</em> to","\t95: include something that is excluded by your <code>.gitignore</code> file, you can","\t97: for <code>.npmignore</code> and <code>.gitignore</code> files in all subdirectories of your","\t100: as <code>.gitignore</code> files:</p>","",""]},{"start":{"row":150,"column":0},"end":{"row":151,"column":0},"action":"insert","lines":["/node_modules/npm/lib/utils/tar.js:",""]},{"start":{"row":151,"column":0},"end":{"row":154,"column":0},"action":"insert","lines":["\t325:       } else if (base === '.gitignore') {","\t326:         var npmignore = this.path.replace(/\\.gitignore$/, '.npmignore')","",""]},{"start":{"row":154,"column":0},"end":{"row":155,"column":0},"action":"insert","lines":["/node_modules/npm/man/man5/npm-json.5:",""]},{"start":{"row":155,"column":0},"end":{"row":157,"column":0},"action":"insert","lines":["\t223: works just like a \\fB\\|\\.gitignore\\fP\\|\\.","",""]},{"start":{"row":157,"column":0},"end":{"row":158,"column":0},"action":"insert","lines":["/node_modules/npm/man/man5/package.json.5:",""]},{"start":{"row":158,"column":0},"end":{"row":160,"column":0},"action":"insert","lines":["\t223: works just like a \\fB\\|\\.gitignore\\fP\\|\\.","",""]},{"start":{"row":160,"column":0},"end":{"row":161,"column":0},"action":"insert","lines":["/node_modules/npm/man/man7/npm-developers.7:",""]},{"start":{"row":161,"column":0},"end":{"row":167,"column":0},"action":"insert","lines":["\t110: no \\fB\\|\\.npmignore\\fP file, but there \\fIis\\fR a \\fB\\|\\.gitignore\\fP file, then npm will","\t111: ignore the stuff matched by the \\fB\\|\\.gitignore\\fP file\\.  If you \\fIwant\\fR to","\t112: include something that is excluded by your \\fB\\|\\.gitignore\\fP file, you can","\t114: for \\fB\\|\\.npmignore\\fP and \\fB\\|\\.gitignore\\fP files in all subdirectories of your","\t118: as \\fB\\|\\.gitignore\\fP files:","",""]}],[{"start":{"row":167,"column":0},"end":{"row":168,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/fstream-npm/fstream-npm.js:",""],"id":12},{"start":{"row":168,"column":0},"end":{"row":175,"column":0},"action":"insert","lines":["\t20:                                              '.gitignore',","\t185:   // read the .gitignore.","\t187:     var i = entries.indexOf('.gitignore')","\t261:   '.gitignore',","\t293:   // if there is a .gitignore, then we're going to","\t295:   if (entry.basename === '.gitignore') {","",""]},{"start":{"row":175,"column":0},"end":{"row":176,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/README.md:",""]},{"start":{"row":176,"column":0},"end":{"row":183,"column":0},"action":"insert","lines":["\t5: `.gitignore` file.","\t12:        , ignoreFiles: [\".ignore\", \".gitignore\"]","\t22: anything matched by the globs in any .iginore or .gitignore file.","","/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/example/basic.js:","\t3:        , ignoreFiles: [\".ignore\", \".gitignore\"]","",""]},{"start":{"row":183,"column":0},"end":{"row":184,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/node_modules/minimatch/package.json:",""]},{"start":{"row":184,"column":0},"end":{"row":189,"column":0},"action":"insert","lines":["\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",","","/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/node_modules/minimatch/README.md:","\t36: * `man 5 gitignore`","",""]},{"start":{"row":189,"column":0},"end":{"row":195,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/fstream-npm/node_modules/fstream-ignore/test/read-file-order.js:","\t6: c.ignores({ \".gitignore\": [\"a/b/c/abc\"] })","\t20: // Overwrite fs.readFile so that when .gitignore and .ignore are read in","\t41:       if (filename.indexOf('.gitignore') !== -1) {","\t62:              , ignoreFiles: [\".gitignore\", \".ignore\"] })","",""]},{"start":{"row":195,"column":0},"end":{"row":199,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/glob/README.md:","\t29: the command line, or put `build/*` in a `.gitignore` file.","\t101: * `man 5 gitignore`","",""]},{"start":{"row":199,"column":0},"end":{"row":200,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/glob/node_modules/minimatch/README.md:",""]},{"start":{"row":200,"column":0},"end":{"row":202,"column":0},"action":"insert","lines":["\t36: * `man 5 gitignore`","",""]}],[{"start":{"row":202,"column":0},"end":{"row":203,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/node-gyp/node_modules/glob/package.json:",""],"id":13},{"start":{"row":203,"column":0},"end":{"row":209,"column":0},"action":"insert","lines":["\t45:   \"readme\": \"[![Build Status](https://travis-ci.org/isaacs/node-glob.svg?branch=master)](https://travis-ci.org/isaacs/node-glob/) [![Dependency Status](https://david-dm.org/isaacs/node-glob.svg)](https://david-dm.org/isaacs/node-glob) [![devDependency Status](https://david-dm.org/isaacs/node-glob/dev-status.svg)](https://david-dm.org/isaacs/node-glob#info=devDependencies) [![optionalDependency Status](https://david-dm.org/isaacs/node-glob/optional-status.svg)](https://david-dm.org/isaacs/node-glob#info=optionalDependencies)\\n\\n# Glob\\n\\nMatch files using the patterns the shell uses, like stars and stuff.\\n\\nThis is a glob implementation in JavaScript.  It uses the `minimatch`\\nlibrary to do its matching.\\n\\n![](oh-my-glob.gif)\\n\\n## Usage\\n\\n```javascript\\nvar glob = require(\\\"glob\\\")\\n\\n// options is optional\\nglob(\\\"**/*.js\\\", options, function (er, files) {\\n  // files is an array of filenames.\\n  // If the `nonull` option is set, and nothing\\n  // was found, then files is [\\\"**/*.js\\\"]\\n  // er is an error object or null.\\n})\\n```\\n\\n## Glob Primer\\n\\n\\\"Globs\\\" are the patterns you type when you do stuff like `ls *.js` on\\nthe command line, or put `build/*` in a `.gitignore` file.\\n\\nBefore parsing the path part patterns, braced sections are expanded\\ninto a set.  Braced sections start with `{` and end with `}`, with any\\nnumber of comma-delimited sections within.  Braced sections may contain\\nslash characters, so `a{/b/c,bcd}` would expand into `a/b/c` and `abcd`.\\n\\nThe following characters have special magic meaning when used in a\\npath portion:\\n\\n* `*` Matches 0 or more characters in a single path portion\\n* `?` Matches 1 character\\n* `[...]` Matches a range of characters, similar to a RegExp range.\\n  If the first character of the range is `!` or `^` then it matches\\n  any character not in the range.\\n* `!(pattern|pattern|pattern)` Matches anything that does not match\\n  any of the patterns provided.\\n* `?(pattern|pattern|pattern)` Matches zero or one occurrence of the\\n  patterns provided.\\n* `+(pattern|pattern|pattern)` Matches one or more occurrences of the\\n  patterns provided.\\n* `*(a|b|c)` Matches zero or more occurrences of the patterns provided\\n* `@(pattern|pat*|pat?erN)` Matches exactly one of the patterns\\n  provided\\n* `**` If a \\\"globstar\\\" is alone in a path portion, then it matches\\n  zero or more directories and subdirectories searching for matches.\\n  It does not crawl symlinked directories.\\n\\n### Dots\\n\\nIf a file or directory path portion has a `.` as the first character,\\nthen it will not match any glob pattern unless that pattern's\\ncorresponding path part also has a `.` as its first character.\\n\\nFor example, the pattern `a/.*/c` would match the file at `a/.b/c`.\\nHowever the pattern `a/*/c` would not, because `*` does not start with\\na dot character.\\n\\nYou can make glob treat dots as normal characters by setting\\n`dot:true` in the options.\\n\\n### Basename Matching\\n\\nIf you set `matchBase:true` in the options, and the pattern has no\\nslashes in it, then it will seek for any file anywhere in the tree\\nwith a matching basename.  For example, `*.js` would match\\n`test/simple/basic.js`.\\n\\n### Negation\\n\\nThe intent for negation would be for a pattern starting with `!` to\\nmatch everything that *doesn't* match the supplied pattern.  However,\\nthe implementation is weird, and for the time being, this should be\\navoided.  The behavior will change or be deprecated in version 5.\\n\\n### Empty Sets\\n\\nIf no matching files are found, then an empty array is returned.  This\\ndiffers from the shell, where the pattern itself is returned.  For\\nexample:\\n\\n    $ echo a*s*d*f\\n    a*s*d*f\\n\\nTo get the bash-style behavior, set the `nonull:true` in the options.\\n\\n### See Also:\\n\\n* `man sh`\\n* `man bash` (Search for \\\"Pattern Matching\\\")\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n* [minimatch documentation](https://github.com/isaacs/minimatch)\\n\\n## glob.hasMagic(pattern, [options])\\n\\nReturns `true` if there are any special characters in the pattern, and\\n`false` otherwise.\\n\\nNote that the options affect the results.  If `noext:true` is set in\\nthe options object, then `+(a|b)` will not be considered a magic\\npattern.  If the pattern has a brace expansion, like `a/{b/c,x/y}`\\nthen that is considered magical, unless `nobrace:true` is set in the\\noptions.\\n\\n## glob(pattern, [options], cb)\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* `cb` {Function}\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nPerform an asynchronous glob search.\\n\\n## glob.sync(pattern, [options])\\n\\n* `pattern` {String} Pattern to be matched\\n* `options` {Object}\\n* return: {Array<String>} filenames found matching the pattern\\n\\nPerform a synchronous glob search.\\n\\n## Class: glob.Glob\\n\\nCreate a Glob object by instantiating the `glob.Glob` class.\\n\\n```javascript\\nvar Glob = require(\\\"glob\\\").Glob\\nvar mg = new Glob(pattern, options, cb)\\n```\\n\\nIt's an EventEmitter, and starts walking the filesystem to find matches\\nimmediately.\\n\\n### new glob.Glob(pattern, [options], [cb])\\n\\n* `pattern` {String} pattern to search for\\n* `options` {Object}\\n* `cb` {Function} Called when an error occurs, or matches are found\\n  * `err` {Error | null}\\n  * `matches` {Array<String>} filenames found matching the pattern\\n\\nNote that if the `sync` flag is set in the options, then matches will\\nbe immediately available on the `g.found` member.\\n\\n### Properties\\n\\n* `minimatch` The minimatch object that the glob uses.\\n* `options` The options object passed in.\\n* `aborted` Boolean which is set to true when calling `abort()`.  There\\n  is no way at this time to continue a glob search after aborting, but\\n  you can re-use the statCache to avoid having to duplicate syscalls.\\n* `statCache` Collection of all the stat results the glob search\\n  performed.\\n* `cache` Convenience object.  Each field has the following possible\\n  values:\\n  * `false` - Path does not exist\\n  * `true` - Path exists\\n  * `'DIR'` - Path exists, and is not a directory\\n  * `'FILE'` - Path exists, and is a directory\\n  * `[file, entries, ...]` - Path exists, is a directory, and the\\n    array value is the results of `fs.readdir`\\n* `statCache` Cache of `fs.stat` results, to prevent statting the same\\n  path multiple times.\\n* `symlinks` A record of which paths are symbolic links, which is\\n  relevant in resolving `**` patterns.\\n* `realpathCache` An optional object which is passed to `fs.realpath`\\n  to minimize unnecessary syscalls.  It is stored on the instantiated\\n  Glob object, and may be re-used.\\n\\n### Events\\n\\n* `end` When the matching is finished, this is emitted with all the\\n  matches found.  If the `nonull` option is set, and no match was found,\\n  then the `matches` list contains the original pattern.  The matches\\n  are sorted, unless the `nosort` flag is set.\\n* `match` Every time a match is found, this is emitted with the matched.\\n* `error` Emitted when an unexpected error is encountered, or whenever\\n  any fs error occurs if `options.strict` is set.\\n* `abort` When `abort()` is called, this event is raised.\\n\\n### Methods\\n\\n* `pause` Temporarily stop the search\\n* `resume` Resume the search\\n* `abort` Stop the search forever\\n\\n### Options\\n\\nAll the options that can be passed to Minimatch can also be passed to\\nGlob to change pattern matching behavior.  Also, some have been added,\\nor have glob-specific ramifications.\\n\\nAll options are false by default, unless otherwise noted.\\n\\nAll options are added to the Glob object, as well.\\n\\nIf you are running many `glob` operations, you can pass a Glob object\\nas the `options` argument to a subsequent operation to shortcut some\\n`stat` and `readdir` calls.  At the very least, you may pass in shared\\n`symlinks`, `statCache`, `realpathCache`, and `cache` options, so that\\nparallel glob operations will be sped up by sharing information about\\nthe filesystem.\\n\\n* `cwd` The current working directory in which to search.  Defaults\\n  to `process.cwd()`.\\n* `root` The place where patterns starting with `/` will be mounted\\n  onto.  Defaults to `path.resolve(options.cwd, \\\"/\\\")` (`/` on Unix\\n  systems, and `C:\\\\` or some such on Windows.)\\n* `dot` Include `.dot` files in normal matches and `globstar` matches.\\n  Note that an explicit dot in a portion of the pattern will always\\n  match dot files.\\n* `nomount` By default, a pattern starting with a forward-slash will be\\n  \\\"mounted\\\" onto the root setting, so that a valid filesystem path is\\n  returned.  Set this flag to disable that behavior.\\n* `mark` Add a `/` character to directory matches.  Note that this\\n  requires additional stat calls.\\n* `nosort` Don't sort the results.\\n* `stat` Set to true to stat *all* results.  This reduces performance\\n  somewhat, and is completely unnecessary, unless `readdir` is presumed\\n  to be an untrustworthy indicator of file existence.\\n* `silent` When an unusual error is encountered when attempting to\\n  read a directory, a warning will be printed to stderr.  Set the\\n  `silent` option to true to suppress these warnings.\\n* `strict` When an unusual error is encountered when attempting to\\n  read a directory, the process will just continue on in search of\\n  other matches.  Set the `strict` option to raise an error in these\\n  cases.\\n* `cache` See `cache` property above.  Pass in a previously generated\\n  cache object to save some fs calls.\\n* `statCache` A cache of results of filesystem information, to prevent\\n  unnecessary stat calls.  While it should not normally be necessary\\n  to set this, you may pass the statCache from one glob() call to the\\n  options object of another, if you know that the filesystem will not\\n  change between calls.  (See \\\"Race Conditions\\\" below.)\\n* `symlinks` A cache of known symbolic links.  You may pass in a\\n  previously generated `symlinks` object to save `lstat` calls when\\n  resolving `**` matches.\\n* `sync` DEPRECATED: use `glob.sync(pattern, opts)` instead.\\n* `nounique` In some cases, brace-expanded patterns can result in the\\n  same file showing up multiple times in the result set.  By default,\\n  this implementation prevents duplicates in the result set.  Set this\\n  flag to disable that behavior.\\n* `nonull` Set to never return an empty set, instead returning a set\\n  containing the pattern itself.  This is the default in glob(3).\\n* `debug` Set to enable debug logging in minimatch and glob.\\n* `nobrace` Do not expand `{a,b}` and `{1..3}` brace sets.\\n* `noglobstar` Do not match `**` against multiple filenames.  (Ie,\\n  treat it as a normal `*` instead.)\\n* `noext` Do not match `+(a|b)` \\\"extglob\\\" patterns.\\n* `nocase` Perform a case-insensitive match.  Note: on\\n  case-insensitive filesystems, non-magic patterns will match by\\n  default, since `stat` and `readdir` will not raise errors.\\n* `matchBase` Perform a basename-only match if the pattern does not\\n  contain any slash characters.  That is, `*.js` would be treated as\\n  equivalent to `**/*.js`, matching all js files in all directories.\\n* `nonegate` Suppress `negate` behavior.  (See below.)\\n* `nocomment` Suppress `comment` behavior.  (See below.)\\n* `nonull` Return the pattern when no matches are found.\\n* `nodir` Do not match directories, only files.  (Note: to match\\n  *only* directories, simply put a `/` at the end of the pattern.)\\n* `ignore` Add a pattern or an array of patterns to exclude matches.\\n* `follow` Follow symlinked directories when expanding `**` patterns.\\n  Note that this can result in a lot of duplicate references in the\\n  presence of cyclic links.\\n* `realpath` Set to true to call `fs.realpath` on all of the results.\\n  In the case of a symlink that cannot be resolved, the full absolute\\n  path to the matched entry is returned (though it will usually be a\\n  broken symlink)\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between node-glob and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.3, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nNote that symlinked directories are not crawled as part of a `**`,\\nthough their contents may match against subsequent portions of the\\npattern.  This prevents infinite loops and duplicates and the like.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen glob returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`glob.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\\n## Windows\\n\\n**Please only use forward-slashes in glob expressions.**\\n\\nThough windows uses either `/` or `\\\\` as its path separator, only `/`\\ncharacters are used by this glob implementation.  You must use\\nforward-slashes **only** in glob expressions.  Back-slashes will always\\nbe interpreted as escape characters, not path separators.\\n\\nResults from absolute patterns such as `/foo/*` are mounted onto the\\nroot setting using `path.join`.  On windows, this will by default result\\nin `/foo/*` matching `C:\\\\foo\\\\bar.txt`.\\n\\n## Race Conditions\\n\\nGlob searching, by its very nature, is susceptible to race conditions,\\nsince it relies on directory walking and such.\\n\\nAs a result, it is possible that a file that exists when glob looks for\\nit may have been deleted or modified by the time it returns the result.\\n\\nAs part of its internal implementation, this program caches all stat\\nand readdir calls that it makes, in order to cut down on system\\noverhead.  However, this also makes it even more susceptible to races,\\nespecially if the cache or statCache objects are reused between glob\\ncalls.\\n\\nUsers are thus advised not to use a glob result as a guarantee of\\nfilesystem state in the face of rapid changes.  For the vast majority\\nof operations, this is never a problem.\\n\\n## Contributing\\n\\nAny change to behavior (including bugfixes) must come with a test.\\n\\nPatches that fail tests or reduce performance will be rejected.\\n\\n```\\n# to run tests\\nnpm test\\n\\n# to re-generate test fixtures\\nnpm run test-regen\\n\\n# to benchmark against bash/zsh\\nnpm run bench\\n\\n# to profile javascript\\nnpm run prof\\n```\\n\",","","/node_modules/npm/node_modules/node-gyp/node_modules/glob/README.md:","\t29: the command line, or put `build/*` in a `.gitignore` file.","\t100: * `man 5 gitignore`","",""]},{"start":{"row":209,"column":0},"end":{"row":215,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/node-gyp/node_modules/glob/node_modules/minimatch/package.json:","\t36:   \"readme\": \"# minimatch\\n\\nA minimal matching utility.\\n\\n[![Build Status](https://secure.travis-ci.org/isaacs/minimatch.png)](http://travis-ci.org/isaacs/minimatch)\\n\\n\\nThis is the matching library used internally by npm.\\n\\nIt works by converting glob expressions into JavaScript `RegExp`\\nobjects.\\n\\n## Usage\\n\\n```javascript\\nvar minimatch = require(\\\"minimatch\\\")\\n\\nminimatch(\\\"bar.foo\\\", \\\"*.foo\\\") // true!\\nminimatch(\\\"bar.foo\\\", \\\"*.bar\\\") // false!\\nminimatch(\\\"bar.foo\\\", \\\"*.+(bar|foo)\\\", { debug: true }) // true, and noisy!\\n```\\n\\n## Features\\n\\nSupports these glob features:\\n\\n* Brace Expansion\\n* Extended glob matching\\n* \\\"Globstar\\\" `**` matching\\n\\nSee:\\n\\n* `man sh`\\n* `man bash`\\n* `man 3 fnmatch`\\n* `man 5 gitignore`\\n\\n## Minimatch Class\\n\\nCreate a minimatch object by instanting the `minimatch.Minimatch` class.\\n\\n```javascript\\nvar Minimatch = require(\\\"minimatch\\\").Minimatch\\nvar mm = new Minimatch(pattern, options)\\n```\\n\\n### Properties\\n\\n* `pattern` The original pattern the minimatch object represents.\\n* `options` The options supplied to the constructor.\\n* `set` A 2-dimensional array of regexp or string expressions.\\n  Each row in the\\n  array corresponds to a brace-expanded pattern.  Each item in the row\\n  corresponds to a single path-part.  For example, the pattern\\n  `{a,b/c}/d` would expand to a set of patterns like:\\n\\n        [ [ a, d ]\\n        , [ b, c, d ] ]\\n\\n    If a portion of the pattern doesn't have any \\\"magic\\\" in it\\n    (that is, it's something like `\\\"foo\\\"` rather than `fo*o?`), then it\\n    will be left as a string rather than converted to a regular\\n    expression.\\n\\n* `regexp` Created by the `makeRe` method.  A single regular expression\\n  expressing the entire pattern.  This is useful in cases where you wish\\n  to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\\n* `negate` True if the pattern is negated.\\n* `comment` True if the pattern is a comment.\\n* `empty` True if the pattern is `\\\"\\\"`.\\n\\n### Methods\\n\\n* `makeRe` Generate the `regexp` member if necessary, and return it.\\n  Will return `false` if the pattern is invalid.\\n* `match(fname)` Return true if the filename matches the pattern, or\\n  false otherwise.\\n* `matchOne(fileArray, patternArray, partial)` Take a `/`-split\\n  filename, and match it against a single row in the `regExpSet`.  This\\n  method is mainly for internal use, but is exposed so that it can be\\n  used by a glob-walker that needs to avoid excessive filesystem calls.\\n\\nAll other methods are internal, and will be called as necessary.\\n\\n## Functions\\n\\nThe top-level exported function has a `cache` property, which is an LRU\\ncache set to store 100 items.  So, calling these methods repeatedly\\nwith the same pattern and options will use the same Minimatch object,\\nsaving the cost of parsing it multiple times.\\n\\n### minimatch(path, pattern, options)\\n\\nMain export.  Tests a path against the pattern using the options.\\n\\n```javascript\\nvar isJS = minimatch(file, \\\"*.js\\\", { matchBase: true })\\n```\\n\\n### minimatch.filter(pattern, options)\\n\\nReturns a function that tests its\\nsupplied argument, suitable for use with `Array.filter`.  Example:\\n\\n```javascript\\nvar javascripts = fileList.filter(minimatch.filter(\\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.match(list, pattern, options)\\n\\nMatch against the list of\\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\\noptions.nonull is set, then return a list containing the pattern itself.\\n\\n```javascript\\nvar javascripts = minimatch.match(fileList, \\\"*.js\\\", {matchBase: true}))\\n```\\n\\n### minimatch.makeRe(pattern, options)\\n\\nMake a regular expression object from the pattern.\\n\\n## Options\\n\\nAll options are `false` by default.\\n\\n### debug\\n\\nDump a ton of stuff to stderr.\\n\\n### nobrace\\n\\nDo not expand `{a,b}` and `{1..3}` brace sets.\\n\\n### noglobstar\\n\\nDisable `**` matching against multiple folder names.\\n\\n### dot\\n\\nAllow patterns to match filenames starting with a period, even if\\nthe pattern does not explicitly have a period in that spot.\\n\\nNote that by default, `a/**/b` will **not** match `a/.d/b`, unless `dot`\\nis set.\\n\\n### noext\\n\\nDisable \\\"extglob\\\" style patterns like `+(a|b)`.\\n\\n### nocase\\n\\nPerform a case-insensitive match.\\n\\n### nonull\\n\\nWhen a match is not found by `minimatch.match`, return a list containing\\nthe pattern itself if this option is set.  When not set, an empty list\\nis returned if there are no matches.\\n\\n### matchBase\\n\\nIf set, then patterns without slashes will be matched\\nagainst the basename of the path if it contains slashes.  For example,\\n`a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\\n\\n### nocomment\\n\\nSuppress the behavior of treating `#` at the start of a pattern as a\\ncomment.\\n\\n### nonegate\\n\\nSuppress the behavior of treating a leading `!` character as negation.\\n\\n### flipNegate\\n\\nReturns from negate expressions the same as if they were not negated.\\n(Ie, true on a hit, false on a miss.)\\n\\n\\n## Comparisons to other fnmatch/glob implementations\\n\\nWhile strict compliance with the existing standards is a worthwhile\\ngoal, some discrepancies exist between minimatch and other\\nimplementations, and are intentional.\\n\\nIf the pattern starts with a `!` character, then it is negated.  Set the\\n`nonegate` flag to suppress this behavior, and treat leading `!`\\ncharacters normally.  This is perhaps relevant if you wish to start the\\npattern with a negative extglob pattern like `!(a|B)`.  Multiple `!`\\ncharacters at the start of a pattern will negate the pattern multiple\\ntimes.\\n\\nIf a pattern starts with `#`, then it is treated as a comment, and\\nwill not match anything.  Use `\\\\#` to match a literal `#` at the\\nstart of a line, or set the `nocomment` flag to suppress this behavior.\\n\\nThe double-star character `**` is supported by default, unless the\\n`noglobstar` flag is set.  This is supported in the manner of bsdglob\\nand bash 4.1, where `**` only has special significance if it is the only\\nthing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\\n`a/**b` will not.\\n\\nIf an escaped pattern has no matches, and the `nonull` flag is set,\\nthen minimatch.match returns the pattern as-provided, rather than\\ninterpreting the character escapes.  For example,\\n`minimatch.match([], \\\"\\\\\\\\*a\\\\\\\\?\\\")` will return `\\\"\\\\\\\\*a\\\\\\\\?\\\"` rather than\\n`\\\"*a?\\\"`.  This is akin to setting the `nullglob` option in bash, except\\nthat it does not resolve escaped pattern characters.\\n\\nIf brace expansion is not disabled, then it is performed before any\\nother interpretation of the glob pattern.  Thus, a pattern like\\n`+(a|{b),c)}`, which would not be valid in bash or zsh, is expanded\\n**first** into the set of `+(a|b)` and `+(a|c)`, and those patterns are\\nchecked for validity.  Since those two are valid, matching proceeds.\\n\",","","/node_modules/npm/node_modules/node-gyp/node_modules/glob/node_modules/minimatch/README.md:","\t36: * `man 5 gitignore`","",""]},{"start":{"row":215,"column":0},"end":{"row":218,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/node-gyp/node_modules/minimatch/README.md:","\t38: * `man 5 gitignore`","",""]}],[{"start":{"row":218,"column":0},"end":{"row":219,"column":0},"action":"insert","lines":["/node_modules/npm/node_modules/validate-npm-package-license/node_modules/spdx-license-ids/package.json:",""],"id":14},{"start":{"row":219,"column":0},"end":{"row":221,"column":0},"action":"insert","lines":["\t15:     \"lint\": \"eslint --config node_modules/@shinnn/eslintrc/rc.json --ignore-path .gitignore .\",","",""]}],[{"start":{"row":221,"column":0},"end":{"row":222,"column":0},"action":"insert","lines":["/node_modules/npm/test/tap/git-npmignore.js:",""],"id":15},{"start":{"row":222,"column":0},"end":{"row":225,"column":0},"action":"insert","lines":["\t28: var gitignore = 'node_modules/\\n'","\t112:   cat(resolve(dep, '.gitignore'), gitignore)","",""]}],[{"start":{"row":225,"column":0},"end":{"row":236,"column":0},"action":"insert","lines":["/node_modules/npm/test/tap/unpack-foreign-tarball.js:","\t15: var target = path.resolve(nm, 'npm-test-gitignore')","\t50: test('gitignore only', function (t) {","\t52:   var file = path.resolve(fixtures, 'gitignore.tgz')","\t56: test('gitignore and npmignore', function (t) {","\t58:   var file = path.resolve(fixtures, 'gitignore-and-npmignore.tgz')","\t62: test('gitignore and npmignore, not gzipped 1/2', function (t) {","\t64:   var file = path.resolve(fixtures, 'gitignore-and-npmignore.tar')","\t68: test('gitignore and npmignore, not gzipped 2/2', function (t) {","\t70:   var file = path.resolve(fixtures, 'gitignore-and-npmignore-2.tar')","",""],"id":16}],[{"start":{"row":236,"column":0},"end":{"row":240,"column":0},"action":"insert","lines":["/node_modules/waterline/node_modules/prompt/node_modules/utile/node_modules/rimraf/node_modules/glob/README.md:","\t29: the command line, or put `build/*` in a `.gitignore` file.","\t101: * `man 5 gitignore`","",""],"id":17}],[{"start":{"row":240,"column":0},"end":{"row":241,"column":0},"action":"insert","lines":["/node_modules/waterline/node_modules/prompt/node_modules/utile/node_modules/rimraf/node_modules/glob/node_modules/minimatch/README.md:",""],"id":18},{"start":{"row":241,"column":0},"end":{"row":243,"column":0},"action":"insert","lines":["\t36: * `man 5 gitignore`","",""]}],[{"start":{"row":243,"column":0},"end":{"row":244,"column":0},"action":"insert","lines":["/public/lib/bootswatch/bower.json:",""],"id":19},{"start":{"row":244,"column":0},"end":{"row":246,"column":0},"action":"insert","lines":["\t22:     \".gitignore\",","",""]}],[{"start":{"row":246,"column":0},"end":{"row":247,"column":0},"action":"insert","lines":["Found 137 matches in 58 files ",""],"id":20}],[{"start":{"row":247,"column":0},"end":{"row":248,"column":0},"action":"insert","lines":["",""],"id":21},{"start":{"row":0,"column":31},"end":{"row":0,"column":63},"action":"insert","lines":[" (Found 137 matches in 58 files)"]}]]},"ace":{"folds":[],"customSyntax":"c9search","scrolltop":3361,"scrollleft":0,"selection":{"start":{"row":248,"column":0},"end":{"row":248,"column":0},"isBackwards":false},"options":{"tabSize":4,"useSoftTabs":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":209,"state":["start",{}],"mode":"ace/mode/c9search"}},"timestamp":1446894662014}